{"meta":{"title":"FTAndy","subtitle":null,"description":null,"author":"FTAndy","url":"https://ftandy.com"},"pages":[{"title":"","date":"2016-10-18T15:12:27.000Z","updated":"2016-09-18T15:08:33.000Z","comments":true,"path":"resume-en.html","permalink":"https://ftandy.com/resume-en.html","excerpt":"","text":"SkillFamiliar With: Ruby on Rails server side development Vue.js, CSS and HTML develop and design web font-end complex page, Node.js server side API development Understand: Javascript preprocessor Babel use ES6 grammar develop Javascript Asynchronous I/O and Event-Driven Model to asynchronous programming use Scss as CSS preprocessor use Webpack as font-end code packaging tool Relational Database Mysql WebSocket，Ajax for real-time interaction use Ruby on Rails + Passenger + Nginx and Node.js + Nginx as server side deployment and operation and maintenance Work Experience北京猎微科技有限公司Position/Time: Font-end Developer（remote） 2016.1~2016.5Project: Stormer is a product like quip and google doc, which is a edit documents online sharing productSummary: Develop web font-end pages, read and parse the document sharing open source library: sharedb, analyze the source to solve the core functionality of the product - document sharing editing 北京北比信息技术有限公司(gold.xitu.io)Position/Time: Node.js/Font-end Developer (inter) 2015.7~2015.10Project: gold.xitu.io is a sharing community, invitation-based technology to invite up to jointly edit and share technical articlesSummary: Meet the requirements of designers, use Vue.js, Webpack, Vue-loader component-based application development single page application Use Leancloud of development based on Node.js service Express develop back-end functionality, based on the principle of complete RESTful backend interface design and development 恒安特斯有限公司(everants.com)Position/Time: Ruby Backend Developer（inter） 2014.7~2015.3Project: led the development of a residential property management system, assist in the development of an electric provider website, a hotel management system and a financial p2p internet. All projects are based on the development of wechat public platformSummary: Master and use Ruby on Rails Based on the development of wechat public Website In each project Use Mysql, Bootstrap, jQuery, Redis, Nginx, Ajax and other technical assistance to develop websites Basic information and contact details Name: Andy Qin &nbsp;&nbsp;&nbsp; Education: Shenyang University of Technology Department of Computer Science degree (2012-2017) CET4&nbsp;&nbsp;&nbsp; Email: fortheandy@gmail.com &nbsp;&nbsp;&nbsp;Blog: ftandy.com &nbsp;&nbsp;&nbsp;Telephone: (+86)186-0766-5805 &nbsp;&nbsp;&nbsp; Wechat: ForTheAndy &nbsp;&nbsp;&nbsp; Github: github.com/ftandy Other Dota2 players, the level of output in the first national service 200 Fluent reading English documents, materials and books Familiar Unix System Operation Use Sublime Text, Git, Chrome as their usual development tools Use Markdown as their writing tools"},{"title":"","date":"2016-10-18T15:12:26.000Z","updated":"2016-05-18T03:18:39.000Z","comments":true,"path":"about/README.html","permalink":"https://ftandy.com/about/README.html","excerpt":"","text":"《Machine Learning in Action》 chapter 3 example use javascript complete."},{"title":"About","date":"2016-12-25T13:32:50.000Z","updated":"2016-12-25T13:32:50.000Z","comments":true,"path":"about/index.html","permalink":"https://ftandy.com/about/index.html","excerpt":"","text":"A Web Developer 网名 FTAndy 取自 Dota 的2009战队名 FTD(For The Dream) 前缀 FT 加上自己的英文名 Andy 前 dota2 天梯玩家，水平曾在国服前200名 相信命运，做一个积极的悲观主义者 信飞天面条神教，不信方便面教和清汤面教 当然拉，还是一个初级膜法师 RAmen! Wubba lubba dub dub！"},{"title":"Categories","date":"2016-10-18T15:12:27.000Z","updated":"2016-09-02T12:14:07.000Z","comments":true,"path":"categories/index.html","permalink":"https://ftandy.com/categories/index.html","excerpt":"","text":""},{"title":"Projecs","date":"2017-02-21T09:28:31.000Z","updated":"2017-02-21T09:28:31.000Z","comments":true,"path":"project/index.html","permalink":"https://ftandy.com/project/index.html","excerpt":"","text":"stand-up-comedian-wiki(developing)A stand up comedian wiki website. Use ES6/ES7, React, Materialize, Mongoose, Express to build the site. mimi-promiseJust a Promises/A+ spec implementation Project. Readable, simple, but not useful to production."},{"title":"Resume","date":"2017-02-09T08:26:26.000Z","updated":"2017-02-09T08:26:26.000Z","comments":false,"path":"resume/index.html","permalink":"https://ftandy.com/resume/index.html","excerpt":"","text":"Work Experience Gaussian Robot职位：客户端/前端工程师 2016.9 ~ 至今项目：机器人远程操控系统 &amp;&amp; 机器人测试工具客户端总结： 使用 Webpack, React 和 Antd 技术栈重构并工程化原 Angular 1.0 的 Electron 机器人测试工具客户端项目，模块化核心代码，优化界面，使得以后需求可以快速实现并上线。 使用 Socket.io，React，Node.js 独立开发机器人远程控制的 IoT 系统，解决了远程文件断点续传和远程调试机器人等核心功能，可支持同时控制 10K 个并发连接。 掘金职位：Node.js/Web 前端工程师(Intern) 2015.7 ~ 2015.10(3个月)项目：掘金是一个技术文章分享社区总结： 使用 Vue.js，Webpack，Vue-Loader 组件化模块化开发掘金前端，开发了早期掘金前端大部分功能，追踪用户需求，使得项目可以快速开发新需求并稳定上线。 使用 Leancloud 的 Node.js SDK 开发和运维掘金后端服务器。 Everants职位：Ruby 后端工程师(Intern) 2014.7 ~ 2015.3(8个月)项目：基于微信公众号 SDK，开发小区物管系统，电商网站，酒店 CMS 系统和 P2P 金融平台。总结：使用 Ruby on Rails 开发基于微信公众号的网站，满足甲方的需求快速开发迭代，交付及时，功能完善。 Programming Language ES6 &amp;&amp; ES5 &amp;&amp; Node.js Ruby Framework Vue &amp;&amp; React Koa 2.0 &amp;&amp; Express.js &amp;&amp; Socket.io Ruby on Rails Tools &amp;&amp; Markup Language HTML5 &amp;&amp; CSS3 Mysql &amp;&amp; MongoDB Nginx Docker &amp;&amp; Vagrant Personal Project Mimi-promise: 符合 Promise/A+ 规范的 Promise 实现 Personal Summary我是一名前端工程师，开发过很多 Web 相关的前后端项目，关注 Javascript 的工程化，模块化，异步控制流，代码规范，可以根据项目的前端需求基本选型和构建项目，快速开发和迭代新需求，并做到功能完备稳定上线。 Personal Info Name：覃宇彬(Andy) Education：沈阳理工大学 计算机系本科(2012-2016) CET4 Email：fortheandy@gmail.com Github：github.com/ftandy Blog：ftandy.com Telephone：(+86)186-0766-5805 Wechat：ForTheAndy Other 前 Dota2 天梯玩家，国服前 200 名 开发环境：*nix，Docker, Atom, Git, Chrome"},{"title":"Interview","date":"2016-10-18T15:12:27.000Z","updated":"2016-09-09T07:41:04.000Z","comments":true,"path":"interview/index.html","permalink":"https://ftandy.com/interview/index.html","excerpt":"","text":"日常你在昨天/本周学到了什么？看了什么书，看了什么博客，研究了什么技术。 编写代码的哪些方面能够使你兴奋或感兴趣？可以通过专研达到自己想要的目的，无论问题是什么，总会有解决办法。 你最近遇到过什么技术挑战？你是如何解决的？每一个问题前人都经历过，所以可以在官方文档，stackoverflow，知乎，个人博客，论文上找到答案，或者直接研究源码。 在制作一个Web应用或Web站点的过程中，你是如何考虑它的UI、安全性、高性能、SEO、可维护性以及技术因素的？UI ：主要是看需求，假如没有需求的情况下，可以跟别人讨论并确定 UI 主题，并让设计书设计。安全性（https://github.com/FallibleInc/security-guide-for-developers）：https，js 脚本注入，js 加密，数据库密码用 bcrypt，session 的安全，权限的保证，手机和邮箱的验证，上传文件用第三方服务，资源的同源使用。高性能：合并css和js，丑化并压缩资源文件，使用cdn，css放头部，js最后加载，资源版本更新加 expires 头和 配置 etag，服务器缓存，资源的zip压缩，js 代码的细节，keepalive 使用都个http连接。SEO：关键词。可维护性：代码模块化，文档维护，代码规范。 谈谈你喜欢的开发环境mac，sublime text，chrome，印象笔记 你最熟悉哪一套版本控制系统？git 你能描述一下当你制作一个网页的工作流程吗？跟设计师确定ui图，拿到ui素材和页面图，布局页面，添加css和js，接入后端数据。 你能描述一下渐进增强和优雅降级之间的不同吗?优雅降级先针对最新，功能最全的浏览器作开发，再作调整适应旧的浏览器。渐进增强先针对旧的浏览器作开发，再在最新的浏览器上做增强功能。 浏览器同一时间可以从一个域名下载多少资源?看浏览器，浏览器版本，http版本 为什么利用多个域名来提供网站资源会更有效？静态内容和动态内容可以用不同的服务器处理，突破资源获取并发限制，cookies传输的节省 请说出三种减少页面加载时间的方法图片合并，利用缓存，gzip压缩资源，头部放css，尾部放js，丑化并压缩资源文件，cdn。 请写一个简单的幻灯效果页面 你都使用哪些工具来测试代码的性能？Profiler, JSPerf, Dromaeo 如果今年你打算熟练掌握一项新技术，那会是什么？机器学习 Long-Polling, Websockets, SSE(Server-Sent Event) 之间有什么区别？ Long Polling:客户端每次发出请求，服务器检查这次请求与上次请求的区别，假如有区别，则返回新数据，否则设置http timeout保持这次连接，直到有新数据出现。 Server-Sent Event：可以实现从服务器到客户端的单方面的实时通信，客户端可以自动获取来自服务器的数据更新，不需要重复发送http请求，客户端会推送事件流到客户端。 WebSocket：客户端与服务器可以双向通信，服务器可以同时通知多个客户端，基于tcp协议的升级 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？载入dom之后，再会导入css样式，中间有一段时间页面只有没有样式的dom。将css放在头部。 请尽可能完整得描述下从输入URL到整个网页加载完毕及显示在屏幕上的整个流程浏览器会对url进行检查，假如是http协议，则按照web来处理。然后进行dns查询ip地址，假如本地有host地址的缓存，则直接使用这个ip地址。然后利用tcp/ip协议来处理http请求。请求包通过网络中的路由传输到服务器。服务器通常都有反向代理服务器作反向处理，请求再由node.js或者rails这样的框架代码作中层处理，服务器再根据后端程序员写的逻辑代码对请求的数据进行特殊处理。根据请求，最终可能返回给服务器一个带有资源的html页面，或者是一段json数据。经过路由传到客户端的时候，先对html进行dom的渲染处理，再利用css文件进行渲染处理，最后再执行javascript。 htmldoctype（文档类型）的作用是什么？doctype使浏览器按照dtd(document type definition)指定的渲染方式对页面进行渲染 浏览器标准模式和怪异模式之间的区别是什么？在很久以前，网页会被写成两个版本：一个为 Netscape Navigator 而写，一个为 Microsoft Internet Explorer 而写。当 WEB 标准由 W3C 制定之后，浏览器却不能立刻使用这些标准，因为这么做会破坏绝大多数WEB 上已经存在的网页的呈现。于是浏览器使用了两种模式来处理符合新标准的页面和遗留的页面不兼容的问题。最大的区别就是盒模型的解释 使用 XHTML 的局限有哪些？要求比较严格，必须有head、body标签且每个元素必须是关闭的。 如果网页内容需要支持多语言，你会怎么做？采用统一编码UTF-8方式编码 data-属性的作用是什么？一个自定义的data属性，可以通过js的dataset获取属性值，不支持dataset用getAttribute获取。 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？&lt;nav&gt;, &lt;header&gt;,&lt;section&gt;, &lt;footer&gt;, SVG,Canvas,web worker 请描述一下 cookies，sessionStorage 和 localStorage 的区别？Storage 完全存储在客户端，不需要通过浏览器的请求传送给服务器。localstorage在浏览器窗口关闭后仍然可以保存，sessionstorage 则是在关闭浏览器窗口后消失，一个页面一个sessionstorage，cookie 则在所有同源的窗口共享。cookies 始终会在同源的http请求中携带，storage 则不会自动传输。cookie 很小 4kb 左右，可设置有效时间。storage 则在5 MB左右 请描述一下 GET 和 POST 的区别?get 用来查数据，post 用来请求操作资源修改信息。get可以在url附带参数，post的数据只能包含在包内。 cssCSS 中类(classes)和 ID 的区别id是唯一的，class是多个的。id可以用于结构布局，css可以用于样式定义。id优先级高于class。 描述下 “reset” CSS 文件的作用和使用它的好处。作用以及好处：因为各个浏览器默认对CSS的渲染有差异，”reset” CSS 通过重新定义标签样式，对浏览器进行默认样式“清零”重置，样式保持一致。 解释下浮动和它的工作原理。浮动出现的最开始出现的意义是用来让文字环绕图片而已。float可以自动包裹元素。float会导致高度塌陷。float为什么会导致高度塌陷：元素含有浮动属性 –&gt; 破坏inline box –&gt; 破坏line box高度 –&gt; 没有高度 –&gt; 塌陷。什么时候会塌陷：当标签里面的元素只要样子没有实际高度时会塌陷。浮动会脱离文档流。产生自己的块级格式化上下文。 描述z-index和叠加上下文是如何形成的因为页面是二维的，而z-index是垂直于页面的第三维，z-index值越大就会越处于遮盖的上层，z-index也允许负值，没有应用z-index的元素默认为0。仅在定位元素上有效：relative，absolute，fixed。 列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。直接把&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;放到当作最后一个子标签放到父标签那儿，此方法兼容性强，使用方便，但是浪费了一个标签，而且只能使用一次，而且有时候如果不注意中间多了个空格会产生一段空白高度。 包含浮动元素的父标签添加css属性overflow:auto; zoom:1; zoom:1 解释下 CSS sprites，以及你要如何在页面或网站中实现它。CSS Sprites就是把网页中一些小图片整合到一张图片文件中，再利用CSS的background-image，background- repeat，background-position的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。可以减少http请求。 你最喜欢的图片替换方法是什么，你如何选择使用。使用background:url() 讨论CSS hacks，条件引用或者其他。我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack 如何为有功能限制的浏览器提供网页？只提供符合 Web 标准的页面；提供另一个符合那些浏览器标准的页面(例如说移动端一套css,电脑端一套css);兼容：这里有两种思路，一个是渐进增强，一个优雅降级。 渐进增强的思路就是提供一个可用的原型，后来再为高级浏览器提供优化。优雅降级的思路是根据高级浏览器提供一个版本，然后有功能限制的浏览器只需要一个刚好能用的版本。当然，工作中的标准都是尽量满足设计，如果不能满足的话就尽量贴近，不得已（性能之类的问题）才会砍掉某个浏览器版本上的需求。 有哪些的隐藏内容的方法（如果同时还要保证屏幕阅读器可用呢？）display:none看不见也摸不着，屏幕阅读器更会忽略其内容；而visibility:hidden虽然看得见但是摸不着，占据了一定的物理空间，屏幕阅读器也会忽略。如果想要在读屏设备中让这些内容可见。解决方案的基本思路都是将这些内容放到屏幕、视线意外的地方，或者就是将大小设置成 0。比如 text-indent: -9999em;、overflow: hidden;、height: 0。 你用过栅格系统吗？如果使用过，你最喜欢哪种？bootstarp，按照规范和文档使用就行。 你用过媒体查询，或针对移动端的布局/CSS 吗？使用@media screen，然后设施最大最小的设备宽度的css。 你熟悉 SVG 样式的书写吗？不是很熟悉。大概知道一点，在svg的tag中定义属性，然后呈现出需要的图片形状和颜色。 如何优化网页的打印样式？&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;xxx.css&quot; /&gt; 其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。 在书写高效 CSS 时会有哪些问题需要考虑？一条普遍规则，不要添加不必要的约束。避免链式选择符。尽可能使用复合语法。尽可能组合重复的规则。避免!important 使用 CSS 预处理器的优缺点有哪些？(SASS，Compass，Stylus，LESS)优点：嵌套语法引入了变量，避免重复@import,mixin,继承extend缺点：提高了学习成本 如果设计中使用了非标准的字体，你该如何去实现？用font字体库（google webfont） 浏览器是如何判断元素是否匹配某个 CSS 选择器？从后往前判断。 浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。 请描述伪元素 (pseudo-elements) 及其用途伪元素是创造文档树之外的对象，伪元素的内容实际上和普通DOM元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素:before:after 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。盒模型由content以及padding，border，margin组成。css的box-sizing:content-box和border-box，一个是标准，一个是怪异。content-box是标准的盒子模型，boreder-box的width包括了padding和border 请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？boreder-box的width包括了padding和border无论如何改动 border 与 padding 的值，都不会导致 box 总尺寸发生变化，也就不会打乱页面整体布局 请罗列出你所知道的 display 属性的全部值none，inline，inline-block，block，contents，table，flex，inline-flex 请解释 inline 和 inline-block 的区别？inline：行内元素，高，行高，上下边距不变，宽度就是文字和图片的宽度。inline-block：行内元素，但是可以设置宽度和高度地块元素的属性 请解释 relative、fixed、absolute 和 static 元素的区别static:无特殊定位fixed:脱离文档流，使用方向属性以窗口为参考点定位，出现滚动条，不会随着滚动。relative:遵循文档六，根据方向属性在文档流中位移。absolute:脱离文档流，根据方向属性进行根据祖先元素的的非static定位。 请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？浏览器缺省 &lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式尽量使用外部样式表来规范工作流程。 你在开发或生产环境中使用过哪些 CSS 框架？你觉得应该如何改善他们？bootstrap，根据需求自定义样式，少用框架。 请问你有尝试过 CSS Flexbox 或者 Grid 标准规格吗？用过flexbox，感觉比table和框架都要原生和规范 为什么响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同？自适应设计：自动识别屏幕宽度、并做出相应调整的网页设计响应式网页设计：自适应网页设计的子集。响应式网页设计指的是页面的布局（流动网格、灵活的图像及媒介查询）响应式布局等于流动网格布局，而自适应布局等于使用固定分割点来进行布局。 使用@media screen和meta name=”viewport” 你有兼容 retina 屏幕的经历吗？如果有，在什么地方使用了何种技术？没有。 请问为何要使用 translate() 而非 absolute positioning，或反之的理由？为什么？原因在于使用绝对定位的动画效果会受制于利用像素(px)为单位进行位移，而使用translate函数的动画则可以不受像素的影响，以更小的单位进行位移。 js请解释事件代理dom模型处理时间分3个阶段：事件捕获，事件目标执行，事件起泡。事件代理就是需要对很多元素进行性事件的时候，通过将事件添加到父节点，把事件委托给父节点来触发事件，利用了事件冒泡事件。 请解释 JavaScript 中 this 是如何工作的js的代码执行环境中都会存在只存在一个上下文，而 this 则是指代这个上下文。全局环境 this 就是指 document 或者 window。在函数内部，决定于函数怎么被调用。在以对象方式环境中使用的时候，this 绑定到该对象。call 和 apply 可以重新定义函数 this 的指向。call 第一个参数是指定调用对象，以后的参数都是函数的参数。apply 第一个参数是制定调用对象，第二个参数是函数参数的数组形式。 请解释原型继承 (prototypal inheritance) 的原理每个对象都有自己的原型，原型对象也有自己的原型，直到原型指向 null。对象的属性定义会覆盖原型的属性定义。假如 o 是对象 a = Object.create(o)，以 o 为原型创造 a 对象假如 o 是构造函数 a = new o() 以 o 为构造函数创造 a 对象proto 是一个不应在你代码中出现的非正规的用法 你怎么看 AMD vs. CommonJS？CommonJS 更容易推广和使用，require 和 exports 比较灵活。webpack 和 node 都是使用commonjs的规范，所以commonjs用起来更加顺手 解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式)：function foo(){ }();.要做哪些改动使它变成 IIFE?因为JavaScript里括弧()里面不能包含语句,解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明 描述以下变量的区别：null，undefined 或 undeclared？undefined 是一个值为 undefined 的类型,JavaScript语言也定义了一个全局变量，它的值是 undefined访问一个undeclared的变量时，js会执行中断并报错。null 中的大部分使用场景都可以用 undefined 代替 什么是闭包 (closure)，如何使用它，为什么要使用它？使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 使用闭包可以在外部访问函数内部的数据。 闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后 请举出一个匿名函数的典型用例？setTimeout，只使用一次函数的场景 你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？模块模式和继承混合使用。 请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？宿主对象是指DOM和BOM。原生对象是Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、Math等对象。 请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？定义person函数，将person函数执行的结果赋予给person，创建一个以person函数为原型的对象person。 .call 和 .apply 的区别是什么？call 是第一个参数以后都是函数的参数，apply 是第二个参数是函数的数组形式参数 请解释 Function.prototype.bind？bind可以创建一个新的函数，函数的this指向bind方法的第一个参数。第二个参数可以设置为预置参数。 在什么时候你会使用 document.write()？document.write会重新打开文档流的写入，清楚当前的文档内容，并写入新的内容。可以写入css文件。 请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？ua字符串嗅探：navigator.userAgent特性检测：特性检测的原理是为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性检测特性推断：特性推断尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能会导致维护性的问题 请尽可能详尽的解释 Ajax 的工作原理？通过XMLHTTPRequest对象向服务器发送异步的请求， 使用 Ajax 都有哪些优劣？优：不需要刷新，异步，广泛支持缺：回退的问题，安全，搜索引擎， 请解释 JSONP(json padding) 的工作原理，以及它为什么不是真正的 Ajax。 标签没有跨域限制的“漏洞”,使用元素，地址指向第三方的API网址并带有回调函数名称的参数，并提供一个回调函数接收数据，返回的js数据马上执行带有json参数的回调函数。 你使用过 JavaScript 模板系统吗？jade 请解释变量声明提升在使用变量后再声明定义变量，变量的声明会提前在使用之前，导致bug。 请描述事件冒泡机制在事件冒泡的过程中，会把事件捕获的节点都检查一点有没有相同的事件绑定，有的话就执行，没有则继续向上冒泡。 “attribute” 和 “property” 的区别是什么？property 是 dom中的属性，javascript中的对象attributr 是 html 标签的特性，值是字符串 为什么扩展 JavaScript 内置对象不是好的做法？会影响到原型链中的所有对象，容易造成bug 请指出 document load 和 document DOMContentLoaded 两个事件的区别当onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。当DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。 == 和 === 有什么不同？==（相等运算法），===（严格相等运算符） JavaScript 对象的比较是引用的比较，非值的比较，对象和其本身相等，和其他任何对象不相等。 === 首先计算其操作数的值，然后比较，比较过程无任何类型转换。 == 如果两个操作数不是同一类型的，则相等运算符进行一些类型转换进行比较只要记住 null 只和undefined 相等，有 number 都转 number，有 boolean 也转number，有 string 都转 string，对象互相不等，NaN 互相不等就可以了 请解释 JavaScript 的同源策略 (same-origin policy)。两个页面具有相同的协议，端口，和主机，就算同源。保证用户安全，Cookie、LocalStorage 和 IndexDB同源，ajax无法发送，无法生成dom 如何实现下列代码：[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5] Array.prototype.duplicator = function () { return this.concat(this) } 什么是三元表达式 (Ternary expression)？“三元 (Ternary)” 表示什么意思？a &gt; b ? c : d 什么是 “use strict”; ? 使用它的好处和坏处分别是什么？严格模式，更加严格地执行js。 - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。缺点：需要更加严格的开发规范 为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？减少名称冲突 利于模块化 请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)可以在浏览器不刷新的情况下完成页面的切换和操作。路由的控制，数据的双向绑定，组件化开发。准备两套方案，判断访问用户是否为蜘蛛，一套直接展示给用户，另一套将模版输出到搜索引擎的爬虫。prerender.io What is the extent of your experience with Promises and/or their polyfills?引入额外的库 使用 Promises 而非回调 (callbacks) 优缺点是什么？优：控制异步的api逻辑流程。更好的异常处理。避免回调地狱。 缺：无原生支持 使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？优可以使用特有的特性，语法糖 缺浏览器兼容团队的协作 你使用哪些工具和技术来调试 JavaScript 代码？node 控制台，chrome 控制台 你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？for(properties in object)Object.keys() 请解释可变 (mutable) 和不变 (immutable) 对象的区别。可变对象都是在原对象上修改数据，并不需要重新创建deepClone(obj)可以克隆一个相同的对象每次修改一个immutable对象都会创建一个新的不可修改的对象，并不会影响到原对象 请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别同步：需要等待函数执行完，才能执行下一步异步：在等待执行结果的过程中，可以执行另外的步骤并等待结果。 什么是事件循环 (event loop)？javascript是单线程模型的编程语言，主线程接受js中的各种事件请求并形成任务队列，事件循环线程会检查任务队列中的事件并执行事件请求，并返回结果给主线程，然后执行回调函数。 测试相关问题：对代码进行测试的有什么优缺点？优：提高代码质量提前发现代码bug 缺：很难做到覆盖每个逻辑点 你会用什么工具测试你的代码功能？Mocha，测试前后端代码功能，不是太熟悉，Ruby 用过minitest 单元测试与功能/集成测试的区别是什么单元测试：对最小可测试的单元进行测试，例如函数，类。功能测试：在考虑到产品功能，特性，界面，架构出发，写测试用例。集成测试：对模块接口写测试用例，同时测试主要业务。 代码风格 linting 工具的作用是什么保证代码风格和代码质量 效能相关问题：你会用什么工具来查找代码中的性能问题benchmark 测试运行速度chrome 的开发者工具的 profile 你会用什么方式来增强网站的页面滚动效能 请解释 layout、painting 和 compositing 的区别。layout：浏览器确定标签占多少位置和大小。painting：标签呈现具体形状的过程。compositing：在页面中使用正确顺序渲染全部标签。 网络相关问题：请描述以下 request 和 response headers：Diff. between Expires, Date, Age and If-Modified-…Do Not TrackCache-ControlTransfer-EncodingETagX-Frame-OptionsExpires:缓存资源的过期时间Age:资源已经在服务器存在多长时间Date:是服务器发送消息的时间Last-Modified:资源最近一次修改的时间If-Modified:最初收到Last-Modified的值Do Not Track:Cache-Control:控制缓存Transfer-Encoding:报文格式,chunkContent-Encoding：内容编码，gzipeTag:资源是否已经改变，辅助缓存X-Frame-Options:允许和拒绝Frame页面"},{"title":"","date":"2016-10-30T16:08:15.000Z","updated":"2016-10-30T16:08:15.000Z","comments":true,"path":"assets/css/andy-style.css","permalink":"https://ftandy.com/assets/css/andy-style.css","excerpt":"","text":"#avatar { height: auto !important; } .process { background: inherit !important; padding: 0px !important; border-style: none !important; border-color: inherit !important; border-width: 0px !important; } body { font-size: 18px !important; } #container { } .highlight { font-size: 18px !important; } .page-number { color: #856f6f; } .widget-wrap { background: #f5f8f9; } .widget-title { padding: 20px 0 0 20px } .logo { background-size: 89px 40px !important; width: 89px !important; height: 40px !important; } .layout-wrap { background: #f5f8f9 !important; }"},{"title":"","date":"2016-10-18T15:12:26.000Z","updated":"2015-08-25T02:20:08.000Z","comments":true,"path":"assets/css/page.css","permalink":"https://ftandy.com/assets/css/page.css","excerpt":"","text":".btn{display:inline-block;padding:4px 12px;margin-bottom:0;font-size:14px;line-height:20px;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;background-image:linear-gradient(to bottom, #fff, #e6e6e6);background-repeat:repeat-x;border:1px solid #bbbbbb;border-color:rgba(0,0,0,0.15) rgba(0,0,0,0.15) rgba(0,0,0,0.25);border-radius:4px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover{background-position:0 -15px;background-color:#e6e6e6;transition:background-position 0.1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:active{background-image:none;outline:0;box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-danger{color:#FFF;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#DA4F49;background-image:linear-gradient(to bottom, #EE5F5B, #BD362F);background-repeat:repeat-x;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25)}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{color:#FFF;background-color:#BD362F}.btn{display:inline-block;padding:4px 12px;margin-bottom:0;font-size:14px;line-height:20px;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;background-image:linear-gradient(to bottom, #fff, #e6e6e6);background-repeat:repeat-x;border:1px solid #bbbbbb;border-color:rgba(0,0,0,0.15) rgba(0,0,0,0.15) rgba(0,0,0,0.25);border-radius:4px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover{background-position:0 -15px;background-color:#e6e6e6;transition:background-position 0.1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:active{background-image:none;outline:0;box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-danger{color:#FFF;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#DA4F49;background-image:linear-gradient(to bottom, #EE5F5B, #BD362F);background-repeat:repeat-x;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25)}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{color:#FFF;background-color:#BD362F}.codehilite{background:#2D2D2D;color:#E4E4E4;margin:1em -20px;padding:16px 20px;line-height:1.4;font-size:1rem;overflow:auto}@media screen and (min-width: 530px){.codehilite{margin-left:-32px;margin-right:0;padding-left:32px;padding-right:0;font-size:1.1rem}}.codehilite pre{font-family:Inconsolata, monospace;margin:0;display:inline-block;padding-right:16px}.codehilite .hll{background-color:#ffc}.codehilite .c{color:#f48c5f}.codehilite .err{color:#E4E4E4}.codehilite .g{color:#E4E4E4}.codehilite .k{color:#b294bb}.codehilite .l{color:#E4E4E4}.codehilite .n{color:#E4E4E4}.codehilite .o{color:#6cc0b7}.codehilite .x{color:#E4E4E4}.codehilite .p{color:#E4E4E4}.codehilite .cm{color:#f48c5f}.codehilite .cp{color:#fcaf3e}.codehilite .c1{color:#f48c5f}.codehilite .cs{color:#f48c5f}.codehilite .gd{color:#2e3436;background-color:#0e1416}.codehilite .ge{color:#E4E4E4}.codehilite .gr{color:#eeeeec;background-color:#c00}.codehilite .gh{color:#fcaf3e}.codehilite .gi{color:#E4E4E4;background-color:#1f2b2d}.codehilite .go{color:#2c3032;background-color:#2c3032}.codehilite .gp{color:#E4E4E4}.codehilite .gs{color:#E4E4E4}.codehilite .gu{color:#fcaf3e}.codehilite .gt{color:#E4E4E4}.codehilite .kc{color:#b294bb}.codehilite .kd{color:#b294bb}.codehilite .kn{color:#b294bb}.codehilite .kp{color:#b294bb}.codehilite .kr{color:#b294bb}.codehilite .kt{color:#e3e7df}.codehilite .ld{color:#E4E4E4}.codehilite .m{color:#f48c5f}.codehilite .s{color:#b2bd67}.codehilite .na{color:#e65b67}.codehilite .nb{color:#f0c674}.codehilite .nc{color:#E4E4E4}.codehilite .no{color:#f48c5f}.codehilite .nd{color:#E4E4E4}.codehilite .ni{color:#888a85}.codehilite .ne{color:#E4E4E4}.codehilite .nf{color:#fcaf3e}.codehilite .nl{color:#E4E4E4}.codehilite .nn{color:#E4E4E4}.codehilite .nx{color:#E4E4E4}.codehilite .py{color:#E4E4E4}.codehilite .nt{color:#e65b67}.codehilite .nv{color:#ffffff}.codehilite .ow{color:#E4E4E4}.codehilite .w{color:#E4E4E4}.codehilite .mf{color:#f48c5f}.codehilite .mh{color:#f48c5f}.codehilite .mi{color:#f48c5f}.codehilite .mo{color:#f48c5f}.codehilite .sb{color:#E4E4E4}.codehilite .sc{color:#E4E4E4}.codehilite .sd{color:#E4E4E4}.codehilite .s2{color:#b2bd67}.codehilite .se{color:#E4E4E4}.codehilite .sh{color:#E4E4E4}.codehilite .si{color:#E4E4E4}.codehilite .sx{color:#E4E4E4}.codehilite .sr{color:#E4E4E4}.codehilite .s1{color:#b2bd67}.codehilite .ss{color:#E4E4E4}.codehilite .bp{color:#E4E4E4}.codehilite .vc{color:#ffffff}.codehilite .vg{color:#ffffff}.codehilite .vi{color:#ffffff}.codehilite .il{color:#f48c5f}.log-output{width:100%;box-sizing:border-box;height:12.7rem;line-height:1.5}.event-loop-walkthrough{overflow:hidden;max-width:710px;background:#eee;display:-webkit-flex;display:flex;-webkit-flex-flow:column;flex-flow:column;max-height:90vh;height:493px;position:relative;margin:0 -20px}@media screen and (min-width: 530px){.event-loop-walkthrough{margin:0}}.event-loop-walkthrough .codehilite{margin:0;padding:0 12px;position:relative;top:60px;-webkit-transform:translateY(-50px);transform:translateY(-50px)}.event-loop-walkthrough table{border-collapse:collapse;width:100%;table-layout:fixed}.event-loop-walkthrough td{padding:0}.task-queue,.microtask-queue,.js-stack,.event-loop-log{line-height:1;border-top:1px solid #FFF}.task-queue th,.microtask-queue th,.js-stack th,.event-loop-log th{font-weight:normal;text-align:left;padding:10px 5px;background:#ddd;vertical-align:top;width:5.1rem}.event-loop-items{display:-webkit-flex;display:flex;overflow:hidden;padding-left:5px}.event-loop-rail{position:relative;display:-webkit-flex;display:flex}.event-loop-log .event-loop-items{-webkit-flex-flow:row wrap;flex-flow:row wrap}.event-loop-item{background:#ddd;margin:5px;padding:5px;margin-left:0;opacity:0;white-space:nowrap}.event-loop-item.active{background-color:#FFDF1E}.event-loop-commentary{pointer-events:none;position:absolute;top:0;left:0;right:0;bottom:0;display:-webkit-flex;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;align-items:center;font-size:1.3rem;color:#fff;line-height:1.2;padding:0 7%}@media screen and (min-width: 530px){.event-loop-commentary{font-size:1.7rem}}.event-loop-commentary-item{background:rgba(0,0,0,0.77);border-radius:7px;padding:0.8rem 1.2rem;opacity:0}.js-source{-webkit-flex:1;flex:1;overflow:hidden;position:relative;background:#2D2D2D}.js-source .line-highlight{position:absolute;left:0;right:0;top:60px;background:rgba(255,255,255,0.2);z-index:1;opacity:0;line-height:1.4;font-size:1rem;font-family:Inconsolata, monospace}.js-source .line-highlight::before{content:'.Hello';color:transparent}@media screen and (min-width: 530px){.js-source .line-highlight::before{font-size:1.1rem}}.event-loop-controls{background:#DDDDDD;fill:#6D6D6D;padding:0.6rem;height:1.7rem;border-top:1px solid #FFF}.event-loop-controls svg{height:100%;display:block;margin-right:0;margin-left:auto}.event-loop-walkthrough .prev-btn,.event-loop-walkthrough .next-btn{fill:transparent;cursor:pointer}.outer-test{background:#D4D4D4;padding:25px;width:92px;margin:0 auto}.inner-test{background:#ADADAD;padding:46px;width:0}.browser-results{display:flex;display:-webkit-flex;justify-content:center;-webkit-justify-content:center;margin:0;padding:0;font-family:Inconsolata, monospace}.browser-results li{display:block;margin:0;padding:0}.browser-results>li{margin-left:1px;background:#eee;padding:0.5rem;padding-bottom:0.4rem;line-height:1.5}@media (min-width: 400px){.browser-results>li{margin-left:1rem}}.browser-results>li:first-child{margin-left:0}.browser-results ul{display:block;margin:0;padding:0}.browser-results img{width:100%;max-width:100px}.codehilite{background:#2D2D2D;color:#E4E4E4;margin:1em -20px;padding:16px 20px;line-height:1.4;font-size:1rem;overflow:auto}@media screen and (min-width: 530px){.codehilite{margin-left:-32px;margin-right:0;padding-left:32px;padding-right:0;font-size:1.1rem}}.codehilite pre{font-family:Inconsolata, monospace;margin:0;display:inline-block;padding-right:16px}.codehilite .hll{background-color:#ffc}.codehilite .c{color:#f48c5f}.codehilite .err{color:#E4E4E4}.codehilite .g{color:#E4E4E4}.codehilite .k{color:#b294bb}.codehilite .l{color:#E4E4E4}.codehilite .n{color:#E4E4E4}.codehilite .o{color:#6cc0b7}.codehilite .x{color:#E4E4E4}.codehilite .p{color:#E4E4E4}.codehilite .cm{color:#f48c5f}.codehilite .cp{color:#fcaf3e}.codehilite .c1{color:#f48c5f}.codehilite .cs{color:#f48c5f}.codehilite .gd{color:#2e3436;background-color:#0e1416}.codehilite .ge{color:#E4E4E4}.codehilite .gr{color:#eeeeec;background-color:#c00}.codehilite .gh{color:#fcaf3e}.codehilite .gi{color:#E4E4E4;background-color:#1f2b2d}.codehilite .go{color:#2c3032;background-color:#2c3032}.codehilite .gp{color:#E4E4E4}.codehilite .gs{color:#E4E4E4}.codehilite .gu{color:#fcaf3e}.codehilite .gt{color:#E4E4E4}.codehilite .kc{color:#b294bb}.codehilite .kd{color:#b294bb}.codehilite .kn{color:#b294bb}.codehilite .kp{color:#b294bb}.codehilite .kr{color:#b294bb}.codehilite .kt{color:#e3e7df}.codehilite .ld{color:#E4E4E4}.codehilite .m{color:#f48c5f}.codehilite .s{color:#b2bd67}.codehilite .na{color:#e65b67}.codehilite .nb{color:#f0c674}.codehilite .nc{color:#E4E4E4}.codehilite .no{color:#f48c5f}.codehilite .nd{color:#E4E4E4}.codehilite .ni{color:#888a85}.codehilite .ne{color:#E4E4E4}.codehilite .nf{color:#fcaf3e}.codehilite .nl{color:#E4E4E4}.codehilite .nn{color:#E4E4E4}.codehilite .nx{color:#E4E4E4}.codehilite .py{color:#E4E4E4}.codehilite .nt{color:#e65b67}.codehilite .nv{color:#ffffff}.codehilite .ow{color:#E4E4E4}.codehilite .w{color:#E4E4E4}.codehilite .mf{color:#f48c5f}.codehilite .mh{color:#f48c5f}.codehilite .mi{color:#f48c5f}.codehilite .mo{color:#f48c5f}.codehilite .sb{color:#E4E4E4}.codehilite .sc{color:#E4E4E4}.codehilite .sd{color:#E4E4E4}.codehilite .s2{color:#b2bd67}.codehilite .se{color:#E4E4E4}.codehilite .sh{color:#E4E4E4}.codehilite .si{color:#E4E4E4}.codehilite .sx{color:#E4E4E4}.codehilite .sr{color:#E4E4E4}.codehilite .s1{color:#b2bd67}.codehilite .ss{color:#E4E4E4}.codehilite .bp{color:#E4E4E4}.codehilite .vc{color:#ffffff}.codehilite .vg{color:#ffffff}.codehilite .vi{color:#ffffff}.codehilite .il{color:#f48c5f} /*# sourceMappingURL=page.css.map */"},{"title":"","date":"2016-10-18T15:12:27.000Z","updated":"2016-09-02T12:02:23.000Z","comments":true,"path":"assets/js/jquery.backstretch.js","permalink":"https://ftandy.com/assets/js/jquery.backstretch.js","excerpt":"","text":"/*! Backstretch - v2.0.4 - 2013-06-19 * http://srobbin.com/jquery-plugins/backstretch/ * Copyright (c) 2013 Scott Robbin; Licensed MIT */ ;(function ($, window, undefined) { 'use strict'; /* PLUGIN DEFINITION * ========================= */ $.fn.backstretch = function (images, options) { // We need at least one image or method name if (images === undefined || images.length === 0) { $.error(\"No images were supplied for Backstretch\"); } /* * Scroll the page one pixel to get the right window height on iOS * Pretty harmless for everyone else */ if ($(window).scrollTop() === 0 ) { window.scrollTo(0, 0); } return this.each(function () { var $this = $(this) , obj = $this.data('backstretch'); // Do we already have an instance attached to this element? if (obj) { // Is this a method they're trying to execute? if (typeof images == 'string' && typeof obj[images] == 'function') { // Call the method obj[images](options); // No need to do anything further return; } // Merge the old options with the new options = $.extend(obj.options, options); // Remove the old instance obj.destroy(true); } obj = new Backstretch(this, images, options); $this.data('backstretch', obj); }); }; // If no element is supplied, we'll attach to body $.backstretch = function (images, options) { // Return the instance return $('body') .backstretch(images, options) .data('backstretch'); }; // Custom selector $.expr[':'].backstretch = function(elem) { return $(elem).data('backstretch') !== undefined; }; /* DEFAULTS * ========================= */ $.fn.backstretch.defaults = { centeredX: true // Should we center the image on the X axis? , centeredY: true // Should we center the image on the Y axis? , duration: 5000 // Amount of time in between slides (if slideshow) , fade: 0 // Speed of fade transition between slides }; /* STYLES * * Baked-in styles that we'll apply to our elements. * In an effort to keep the plugin simple, these are not exposed as options. * That said, anyone can override these in their own stylesheet. * ========================= */ var styles = { wrap: { left: 0 , top: 0 , overflow: 'hidden' , margin: 0 , padding: 0 , height: '100%' , width: '100%' , zIndex: -999999 } , img: { position: 'absolute' , display: 'none' , margin: 0 , padding: 0 , border: 'none' , width: 'auto' , height: 'auto' , maxHeight: 'none' , maxWidth: 'none' , zIndex: -999999 } }; /* CLASS DEFINITION * ========================= */ var Backstretch = function (container, images, options) { this.options = $.extend({}, $.fn.backstretch.defaults, options || {}); /* In its simplest form, we allow Backstretch to be called on an image path. * e.g. $.backstretch('/path/to/image.jpg') * So, we need to turn this back into an array. */ this.images = $.isArray(images) ? images : [images]; // Preload images $.each(this.images, function () { $('')[0].src = this; }); // Convenience reference to know if the container is body. this.isBody = container === document.body; /* We're keeping track of a few different elements * * Container: the element that Backstretch was called on. * Wrap: a DIV that we place the image into, so we can hide the overflow. * Root: Convenience reference to help calculate the correct height. */ this.$container = $(container); this.$root = this.isBody ? supportsFixedPosition ? $(window) : $(document) : this.$container; // Don't create a new wrap if one already exists (from a previous instance of Backstretch) var $existing = this.$container.children(\".backstretch\").first(); this.$wrap = $existing.length ? $existing : $('').css(styles.wrap).appendTo(this.$container); // Non-body elements need some style adjustments if (!this.isBody) { // If the container is statically positioned, we need to make it relative, // and if no zIndex is defined, we should set it to zero. var position = this.$container.css('position') , zIndex = this.$container.css('zIndex'); this.$container.css({ position: position === 'static' ? 'relative' : position , zIndex: zIndex === 'auto' ? 0 : zIndex , background: 'none' }); // Needs a higher z-index this.$wrap.css({zIndex: -999998}); } // Fixed or absolute positioning? this.$wrap.css({ position: this.isBody && supportsFixedPosition ? 'fixed' : 'absolute' }); // Set the first image this.index = 0; this.show(this.index); // Listen for resize $(window).on('resize.backstretch', $.proxy(this.resize, this)) .on('orientationchange.backstretch', $.proxy(function () { // Need to do this in order to get the right window height if (this.isBody && window.pageYOffset === 0) { window.scrollTo(0, 1); this.resize(); } }, this)); }; /* PUBLIC METHODS * ========================= */ Backstretch.prototype = { resize: function () { try { var bgCSS = {left: 0, top: 0} , rootWidth = this.isBody ? this.$root.width() : this.$root.innerWidth() , bgWidth = rootWidth , rootHeight = this.isBody ? ( window.innerHeight ? window.innerHeight : this.$root.height() ) : this.$root.innerHeight() , bgHeight = bgWidth / this.$img.data('ratio') , bgOffset; // Make adjustments based on image ratio if (bgHeight >= rootHeight) { bgOffset = (bgHeight - rootHeight) / 2; if(this.options.centeredY) { bgCSS.top = '-' + bgOffset + 'px'; } } else { bgHeight = rootHeight; bgWidth = bgHeight * this.$img.data('ratio'); bgOffset = (bgWidth - rootWidth) / 2; if(this.options.centeredX) { bgCSS.left = '-' + bgOffset + 'px'; } } this.$wrap.css({width: rootWidth, height: rootHeight}) .find('img:not(.deleteable)').css({width: bgWidth, height: bgHeight}).css(bgCSS); } catch(err) { // IE7 seems to trigger resize before the image is loaded. // This try/catch block is a hack to let it fail gracefully. } return this; } // Show the slide at a certain position , show: function (newIndex) { // Validate index if (Math.abs(newIndex) > this.images.length - 1) { return; } // Vars var self = this , oldImage = self.$wrap.find('img').addClass('deleteable') , evtOptions = { relatedTarget: self.$container[0] }; // Trigger the \"before\" event self.$container.trigger($.Event('backstretch.before', evtOptions), [self, newIndex]); // Set the new index this.index = newIndex; // Pause the slideshow clearInterval(self.interval); // New image self.$img = $('') .css(styles.img) .bind('load', function (e) { var imgWidth = this.width || $(e.target).width() , imgHeight = this.height || $(e.target).height(); // Save the ratio $(this).data('ratio', imgWidth / imgHeight); // Show the image, then delete the old one // \"speed\" option has been deprecated, but we want backwards compatibilty $(this).fadeIn(self.options.speed || self.options.fade, function () { oldImage.remove(); // Resume the slideshow if (!self.paused) { self.cycle(); } // Trigger the \"after\" and \"show\" events // \"show\" is being deprecated $(['after', 'show']).each(function () { self.$container.trigger($.Event('backstretch.' + this, evtOptions), [self, newIndex]); }); }); // Resize self.resize(); }) .appendTo(self.$wrap); // Hack for IE img onload event self.$img.attr('src', self.images[newIndex]); return self; } , next: function () { // Next slide return this.show(this.index < this.images.length - 1 ? this.index + 1 : 0); } , prev: function () { // Previous slide return this.show(this.index === 0 ? this.images.length - 1 : this.index - 1); } , pause: function () { // Pause the slideshow this.paused = true; return this; } , resume: function () { // Resume the slideshow this.paused = false; this.next(); return this; } , cycle: function () { // Start/resume the slideshow if(this.images.length > 1) { // Clear the interval, just in case clearInterval(this.interval); this.interval = setInterval($.proxy(function () { // Check for paused slideshow if (!this.paused) { this.next(); } }, this), this.options.duration); } return this; } , destroy: function (preserveBackground) { // Stop the resize events $(window).off('resize.backstretch orientationchange.backstretch'); // Clear the interval clearInterval(this.interval); // Remove Backstretch if(!preserveBackground) { this.$wrap.remove(); } this.$container.removeData('backstretch'); } }; /* SUPPORTS FIXED POSITION? * * Based on code from jQuery Mobile 1.1.0 * http://jquerymobile.com/ * * In a nutshell, we need to figure out if fixed positioning is supported. * Unfortunately, this is very difficult to do on iOS, and usually involves * injecting content, scrolling the page, etc.. It's ugly. * jQuery Mobile uses this workaround. It's not ideal, but works. * * Modified to detect IE6 * ========================= */ var supportsFixedPosition = true }(jQuery, window));"},{"title":"","date":"2016-10-18T15:12:27.000Z","updated":"2015-09-27T17:02:10.000Z","comments":true,"path":"assets/js/task.js","permalink":"https://ftandy.com/assets/js/task.js","excerpt":"","text":"/** * script 1 */ function log1(str) { console.log(str); var logEl = document.querySelector('.log-output-1'); logEl.value += (logEl.value ? '\\n' : '') + str; } document.querySelector('.clear-log-1').addEventListener('click', function () { document.querySelector('.log-output-1').value = ''; }); document.querySelector('.test-1').addEventListener('click', function () { log1('script start'); setTimeout(function () { log1('setTimeout'); }, 0); Promise.resolve().then(function () { log1('promise1'); }).then(function () { log1('promise2'); }); log1('script end'); }); /** * script 2 */ (function () { function transition(el, obj, duration, easing) { return new Promise(function (resolve, reject) { if (obj.transform) { obj['-webkit-transform'] = obj.transform; } var objKeys = Object.keys(obj); if (duration) { el.style.transitionProperty = objKeys.join(); el.style.transitionTimingFunction = easing; el.style.transitionDuration = duration + 's'; el.offsetLeft; // style recalc el.addEventListener('transitionend', function te() { el.style.transitionProperty = ''; el.style.transitionTimingFunction = ''; el.style.transitionDuration = ''; resolve(); el.removeEventListener('transitionend', te); }); } else { resolve(); } objKeys.forEach(function (key) { el.style.setProperty(key, obj[key]); }); }); } function EventLoopAnimation(el) { this._initalState = el; this._states = []; this._el = el; this._queue = Promise.resolve(); this._reset(); } EventLoopAnimation.prototype._reset = function () { var newEl = this._initalState.cloneNode(true); this._tasksShown = 0; this._microtasksShown = 0; this._tasksRemoved = 0; this._microtasksRemoved = 0; this._logsShown = 0; this._currentPos = 0; this._el.parentNode.insertBefore(newEl, this._el); this._el.parentNode.removeChild(this._el); this._el = newEl; this._taskRail = this._el.querySelector('.task-queue .event-loop-rail'); this._microtaskRail = this._el.querySelector('.microtask-queue .event-loop-rail'); this._jsStack = this._el.querySelector('.js-stack .event-loop-items'); this._log = this._el.querySelector('.event-loop-log .event-loop-items'); this._codeBar = this._el.querySelector('.line-highlight'); this._codePane = this._el.querySelector('.codehilite'); this._commentary = this._el.querySelector('.event-loop-commentary-item'); var onClick = function (event) { var className = event.target.getAttribute('class'); if (className === 'prev-btn') { event.preventDefault(); if (event.type == 'click') { this.back(); } } else if (className === 'next-btn') { event.preventDefault(); if (event.type == 'click') { this.forward(true); } } }.bind(this); this._el.addEventListener('click', onClick); this._el.addEventListener('mousedown', onClick); }; EventLoopAnimation.prototype.forward = function (animate) { this._queue = this._queue.then(function () { var state = this._states[this._currentPos]; if (!state) return this.goTo(0); this._currentPos++; return Promise.all( state.map(function (func) { return func(animate); }) ); }.bind(this)); }; EventLoopAnimation.prototype.goTo = function (pos) { this._queue = this._queue.then(function () { this._reset(); while (pos--) { this.forward(false); } }.bind(this)); }; EventLoopAnimation.prototype.back = function () { this._queue = this._queue.then(function () { if (this._currentPos === 0) return this.goTo(this._states.length); return this.goTo(this._currentPos - 1); }.bind(this)); }; EventLoopAnimation.prototype.state = function () { this._states.push([]); return this; }; EventLoopAnimation.prototype.action = function (func) { this._states[this._states.length - 1].push(func); return this; }; EventLoopAnimation.prototype.pushTask = function (activated) { return this.action(function (animate) { var newTask = this._taskRail.children[this._tasksShown]; this._tasksShown++; if (activated) { newTask.style.backgroundColor = '#FFDF1E'; } return transition(newTask, { opacity: 1 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.pushMicrotask = function () { return this.action(function (animate) { var newTask = this._microtaskRail.children[this._microtasksShown]; this._microtasksShown++; return transition(newTask, { opacity: 1 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.pushStack = function (text) { return this.action(function (animate) { var div = document.createElement('div'); div.className = 'event-loop-item'; div.textContent = text; div.style.backgroundColor = '#FFDF1E'; this._jsStack.appendChild(div); return transition(div, { opacity: 1 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.popStack = function (text) { return this.action(function (animate) { var div = this._jsStack.children[this._jsStack.children.length - 1]; return transition(div, { opacity: 0 }, 0.2 * animate, 'ease-in-out').then(function () { this._jsStack.removeChild(div); }.bind(this)); }.bind(this)); }; EventLoopAnimation.prototype.showCodeBar = function () { return this.action(function (animate) { return transition(this._codeBar, { opacity: 1 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.hideCodeBar = function () { return this.action(function (animate) { return transition(this._codeBar, { opacity: 0 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.pushLog = function () { return this.action(function (animate) { var newLog = this._log.children[this._logsShown]; this._logsShown++; return transition(newLog, { opacity: 1 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.moveToLine = function (num) { return this.action(function (animate) { var barHeight = this._codeBar.getBoundingClientRect().height; return transition(this._codePane, { transform: 'translateY(' + ((num - 1) * -barHeight) + 'px)' }, 0.3 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.commentary = function (text) { return this.action(function (animate) { this._commentary.textContent = text; return transition(this._commentary, { opacity: 1 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.hideCommentary = function () { return this.action(function (animate) { return transition(this._commentary, { opacity: 0 }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.activateMicrotask = function () { return this.action(function (animate) { var div = this._microtaskRail.children[this._microtasksRemoved]; return transition(div, { 'background-color': '#FFDF1E' }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.shiftMicrotask = function () { return this.action(function (animate) { this._microtasksRemoved++; var offset; var offsetEl = this._microtaskRail.children[this._microtasksRemoved]; if (offsetEl) { offset = offsetEl.offsetLeft; } else { offset = this._microtaskRail.offsetWidth; } return transition(this._microtaskRail, { 'transform': 'translateX(' + (-offset) + 'px)' }, 0.3 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.activateTask = function () { return this.action(function (animate) { var div = this._taskRail.children[this._tasksRemoved]; return transition(div, { 'background-color': '#FFDF1E' }, 0.2 * animate, 'ease-in-out'); }.bind(this)); }; EventLoopAnimation.prototype.shiftTask = function () { return this.action(function (animate) { this._tasksRemoved++; var offset; var offsetEl = this._taskRail.children[this._tasksRemoved]; if (offsetEl) { offset = offsetEl.offsetLeft; } else { offset = this._taskRail.offsetWidth; } return transition(this._taskRail, { 'transform': 'translateX(' + (-offset) + 'px)' }, 0.3 * animate, 'ease-in-out'); }.bind(this)); }; window.EventLoopAnimation = EventLoopAnimation; }()); new EventLoopAnimation(document.querySelector('.event-loop-walkthrough-1')) .state().moveToLine(1).pushTask(true).pushStack('script').showCodeBar() .state().pushLog() .state().moveToLine(3) .state().commentary(\"setTimeout callbacks are queued as tasks\") .state().hideCommentary().pushTask() .state().moveToLine(7) .state().commentary(\"Promise callbacks are queued as microtasks\") .state().hideCommentary().pushMicrotask() .state().moveToLine(13) .state().pushLog() .state().hideCodeBar().popStack() .state().commentary(\"At the end of a task, we process microtasks\") .state().hideCommentary().activateMicrotask() .state().showCodeBar().moveToLine(8).pushStack('Promise callback') .state().pushLog() .state().hideCodeBar().commentary(\"This promise callback returns 'undefined', which queues the next promise callback as a microtask\") .state().hideCommentary().pushMicrotask() .state().popStack().commentary(\"This microtask is done so we move onto the next one in the queue\") .state().hideCommentary() .state().shiftMicrotask().activateMicrotask() .state().showCodeBar().moveToLine(10).pushStack('Promise callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask() .state().commentary(\"And that's this task done! The browser may update rendering\") .state().hideCommentary() .state().shiftTask().activateTask() .state().showCodeBar().moveToLine(4).pushStack('setTimeout callback') .state().pushLog() .state().hideCodeBar().popStack() .state().shiftTask() .state().commentary('fin'); /** * script 3 */ var targetLogOutput; function log2(str) { console.log(str); var el; if (jsActivatedClick) { el = document.querySelector('.log-output-3'); } else { el = document.querySelector('.log-output-2'); } el.value += (el.value ? '\\n' : '') + str; } document.querySelector('.clear-log-2').addEventListener('click', function () { document.querySelector('.log-output-2').value = ''; }); // Let's get hold of those elements var outer = document.querySelector('.outer-test'); var inner = document.querySelector('.inner-test'); // Let's listen for attribute changes on the // outer element new MutationObserver(function () { log2('mutate'); }).observe(outer, { attributes: true }); // Here's a click listener… function onClick() { log2('click'); setTimeout(function () { log2('timeout'); }, 0); Promise.resolve().then(function () { log2('promise'); }); outer.setAttribute('data-random', Math.random()); } // …which we'll attach to both elements inner.addEventListener('click', onClick); outer.addEventListener('click', onClick); /** * script 4 */ new EventLoopAnimation(document.querySelector('.event-loop-walkthrough-2')) .state().pushTask(true) .state().moveToLine(15).pushStack('onClick').showCodeBar() .state().pushLog() .state().moveToLine(17) .state().pushTask() .state().moveToLine(21) .state().pushMicrotask() .state().moveToLine(25) .state().commentary(\"This mutation queues a microtask to handle observers\") .state().hideCommentary().pushMicrotask() .state().hideCodeBar().popStack() .state().commentary(\"Although we're mid-task, microtasks are processed after callbacks if the stack is empty\") .state().hideCommentary().activateMicrotask() .state().showCodeBar().moveToLine(22).pushStack('Promise callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask() .state().showCodeBar().moveToLine(8).pushStack('Mutation callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask() .state().commentary(\"The event bubbles, so our callback is called again for the outer element\") .state().hideCommentary().moveToLine(15).pushStack('onClick').showCodeBar() .state().pushLog() .state().moveToLine(17) .state().pushTask() .state().moveToLine(21) .state().pushMicrotask() .state().moveToLine(25) .state().pushMicrotask() .state().hideCodeBar().popStack() .state().activateMicrotask() .state().showCodeBar().moveToLine(22).pushStack('Promise callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask() .state().showCodeBar().moveToLine(8).pushStack('Mutation callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask() .state().shiftTask().activateTask() .state().showCodeBar().moveToLine(18).pushStack('setTimeout callback') .state().pushLog() .state().popStack().hideCodeBar().shiftTask().activateTask() .state().showCodeBar().pushStack('setTimeout callback') .state().pushLog() .state().popStack().hideCodeBar().shiftTask() .state().commentary('fin'); /** * script 5 */ var jsActivatedClick = false; document.querySelector('.test-2').addEventListener('click', function () { jsActivatedClick = true; inner.click(); setTimeout(function () { jsActivatedClick = false; }, 100); }); document.querySelector('.clear-log-3').addEventListener('click', function () { document.querySelector('.log-output-3').value = ''; }); /** * script 6 */ new EventLoopAnimation(document.querySelector('.event-loop-walkthrough-3')) .state().pushTask(true).pushStack('script') .state().moveToLine(32).showCodeBar() .state().moveToLine(15).pushStack('onClick') .state().pushLog() .state().moveToLine(17) .state().pushTask() .state().moveToLine(21) .state().pushMicrotask() .state().moveToLine(25) .state().pushMicrotask() .state().hideCodeBar().popStack() .state().commentary(\"We cannot process microtasks, the stack is not empty\") .state().hideCommentary() .state().moveToLine(15).showCodeBar().pushStack('onClick') .state().pushLog() .state().moveToLine(17) .state().pushTask() .state().moveToLine(21) .state().pushMicrotask() .state().moveToLine(25) .state().commentary(\"We don't add another mutation microtask as one is already pending\") .state().hideCommentary().hideCodeBar().popStack() .state().moveToLine(32).showCodeBar() .state().hideCodeBar().popStack() .state().commentary(\"We're at the end of this task, so now we can process microtasks\") .state().hideCommentary().activateMicrotask() .state().showCodeBar().moveToLine(22).pushStack('Promise callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask() .state().showCodeBar().moveToLine(8).pushStack('Mutation callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask().activateMicrotask() .state().showCodeBar().moveToLine(22).pushStack('Promise callback') .state().pushLog() .state().hideCodeBar().popStack().shiftMicrotask() .state().shiftTask().activateTask() .state().showCodeBar().moveToLine(18).pushStack('setTimeout callback') .state().pushLog() .state().popStack().hideCodeBar().shiftTask().activateTask() .state().showCodeBar().pushStack('setTimeout callback') .state().pushLog() .state().popStack().hideCodeBar().shiftTask() .state().commentary('fin');"}],"posts":[{"title":"Node 根本就不是什么新东西","slug":"Node-根本就不是什么新东西","date":"2017-01-17T14:44:15.000Z","updated":"2017-01-17T15:08:56.000Z","comments":true,"path":"2017/01/17/Node-根本就不是什么新东西/","link":"","permalink":"https://ftandy.com/2017/01/17/Node-根本就不是什么新东西/","excerpt":"","text":"逛 github 看到 uWebSockets 作者 Alex Hultman 写的有关 Node 的话，很有感触。 第一篇 The-real-history-of-async-networking，讲的是异步编程的历史，然后总结出 Node 并不是新概念，只是一群没有经验程序员的玩具。 From the perspective of a PHP programmer it might be something new, but from the perspective of an experienced C programmer this piece of software is nothing more than a simplification of common (now ancient) async techniques wrapped up in JavaScript for non-experienced programmers to toy with 确实也无可厚非。 第二篇 Don-t-bother-counting-those-stars，讲的是低质量的库，假如做了宣传，star 飙升，但是并没有否定这是一个低质量库的现实。而很多高质量的库因为没有宣传，star 少，但是实用。总结为不要看 star 数量而用一个库。 You won’t get many stars with marketing like “We are not the fastest but we are pretty efficient, no wait, we are actually not that fast”. It has to be something like “FEATURING THE FASTEST AND MOST RELIABLE REAL-TIME ENGINE”. Yeah, that one will sell. In fact, this is the marketing of Socket.IO, a project with 28k stars. 确实，最近用到 Socket.io，质量确实不好，而且很久没人维护。 Node 09 年刚出现的时候被大吹特吹，被贴上异步事件驱动，高并发等标签，入门门槛极低，大量前端都可以跳到 Node写一下。一些无高质量的基础库涌现，库作者会吹 B，而且前端的人很多，这些库 star 数飙升，例如 Socket.io。但是到现在出现了性能低，无人维护等现象。 估计 Node 要称为下一个 Ruby 了。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}],"tags":[],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}]},{"title":"写一个符合 Promises/A+ 规范并可配合 ES7 async/await 使用的 Promise","slug":"mimi-promise","date":"2016-10-30T14:11:46.000Z","updated":"2016-10-30T16:03:54.000Z","comments":true,"path":"2016/10/30/mimi-promise/","link":"","permalink":"https://ftandy.com/2016/10/30/mimi-promise/","excerpt":"原文地址 从历史的进程来看，Javascript 异步操作的基本单位已经从 callback 转换到 Promise。除了在特殊场景使用 stream，RxJs 等更加抽象和高级的异步数据获取和操作流程方式外，现在几乎任何成熟的异步操作库，都会实现或者引用 Promise 作为 API 的返回单位。主流的 Javascript 引擎也基本原生实现了 Promise。 在 Promise 远未流行以前，Javascript 的异步操作基本都在使用以 callback 为主的异步接口。鼠标键盘事件，页面渲染，网络请求，文件请求等等异步操作的回调函数都是用 callback 来处理。随着异步使用场景范围的扩大，出现了大量工程化和富应用的的交互和操作，使得应用不足以用 callback 来面对愈加复杂的需求，慢慢出现了许多优雅和先进的异步解决方案：EventEmitter，Promise，Web Worker，Generator，Async/Await。 目前 Javascript 在客户端和服务器端的应用当中，只有 Promise 被广泛接受并使用。追根溯源，Promise 概念的提出是在 1976 年，Javascript 最早的 Promise 实现是在 2007 年，到现在 2016 年，Promise/A+ 规范和 ECMAscript 规范提出的 API 也足够稳定。then, reject, all, spread, race, finally 都是工程师开发中经常用到的 Promise API。很多人刚接触 Promise 概念的时候看下 API，看几篇博客或者看几篇最佳实践就以为理解程度够了，但是对 Promise 内部的异步机制不明了，使得在开发过程中遇到不少坑或者懵逼。 本文旨在让读者能深入了解 Promise 内部执行机制，熟悉和掌握 Promise 的操作流。如有兴趣，可以继续往下读。","text":"原文地址 从历史的进程来看，Javascript 异步操作的基本单位已经从 callback 转换到 Promise。除了在特殊场景使用 stream，RxJs 等更加抽象和高级的异步数据获取和操作流程方式外，现在几乎任何成熟的异步操作库，都会实现或者引用 Promise 作为 API 的返回单位。主流的 Javascript 引擎也基本原生实现了 Promise。 在 Promise 远未流行以前，Javascript 的异步操作基本都在使用以 callback 为主的异步接口。鼠标键盘事件，页面渲染，网络请求，文件请求等等异步操作的回调函数都是用 callback 来处理。随着异步使用场景范围的扩大，出现了大量工程化和富应用的的交互和操作，使得应用不足以用 callback 来面对愈加复杂的需求，慢慢出现了许多优雅和先进的异步解决方案：EventEmitter，Promise，Web Worker，Generator，Async/Await。 目前 Javascript 在客户端和服务器端的应用当中，只有 Promise 被广泛接受并使用。追根溯源，Promise 概念的提出是在 1976 年，Javascript 最早的 Promise 实现是在 2007 年，到现在 2016 年，Promise/A+ 规范和 ECMAscript 规范提出的 API 也足够稳定。then, reject, all, spread, race, finally 都是工程师开发中经常用到的 Promise API。很多人刚接触 Promise 概念的时候看下 API，看几篇博客或者看几篇最佳实践就以为理解程度够了，但是对 Promise 内部的异步机制不明了，使得在开发过程中遇到不少坑或者懵逼。 本文旨在让读者能深入了解 Promise 内部执行机制，熟悉和掌握 Promise 的操作流。如有兴趣，可以继续往下读。 Promise 只是一个 Event Loop 中的 microtask深入了解过 Promise 的人都知道，Promise 所说的异步执行，只是将 Promise 构造函数中 resolve，reject 方法和注册的 callback 转化为 eventLoop的 microtask/Promise Job，并放到 Event Loop 队列中等待执行，也就是 Javascript 单线程中的“异步执行”。 Promise/A+ 规范中，并没有明确是以 microtask 还是 macrotask 形式放入队列，对没有 microtask 概念的宿主环境采用 setTimeout 等 task/Job 类的任务。规范中另外明确的一点也非常重要：回调函数的异步调用必须在当前 context，也就是 JS stack 为空之后执行。 在最新的 ECMAScript 规范 中，明确了 Promise 必须以 Promise Job 的形式入 Job 队列（也就是 microtask），并仅在没有运行的 stack(stack 为空的情况下)才可以初始化执行。 HTML 规范 也提出，在 stack 清空后，执行 microtask 的检查方法。也就是必须在 stack 为空的情况下才能执行。 Google Chrome 的开发者 Jake Archibald （ES6-promise 作者）的文章 Tasks, microtasks, queues and schedules中，将这个区分的问题描述得很清楚。假如要在 Javascript 平台或者引擎中实现 Promise，优先以 microtask/Promise Job 方式实现。目前主流浏览器的 Javascript 引擎原生实现，主流的 Promise 库（es6-promise，bluebrid）基本都是使用 microtask/Promise Job 的形式将 Promise 放入队列。 其他以 microtask/Promise Job 形式实现的方法还有：process.nextTick，setImmediate，postMessage，MessageChannel 等 根据规范，microtask 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 microtask。原生的 setTimeout 就算是将延迟设置为 0 也会有 4 ms 的延迟，会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 microtask。 这里的 Quick Sort Demo 展示了 microtask 和 task 在延迟执行上的巨大区别。 对于在不通宿主环境中选择合适的 microtask，可以选择 asap 和 setImmediate 的代码作为参考。 Promise 的中的同步与异步123456789new Promise((resolve) =&gt; &#123; console.log('a') resolve('b') console.log('c')&#125;).then((data) =&gt; &#123; console.log(data)&#125;)// a, c, b 使用过 Promise 的人都知道输出 a, c, b，但有多少人可以清楚地说出从创建 Promise 对象到执行完回调的过程？下面是一个完整的解释： 构造函数中的输出执行是同步的，输出 a, 执行 resolve 函数，将 Promise 对象状态置为 resolved，输出 c。同时注册这个 Promise 对象的回调 then 函数。整个脚本执行完，stack 清空。event loop 检查到 stack 为空，再检查 microtask 队列中是否有任务，发现了 Promise 对象的 then 回调函数产生的 microtask，推入 stack，执行。输出 b，event loop的列队为空，stack 为空，脚本执行完毕。 以基础的 Promises/A+ 规范为范本规范地址： Promises/A+ 规范（中文） Promises/A+ 规范（英文） 值得注意的是： Finally, the core Promises/A+ specification does not deal with how to create, fulfill, or reject promises, choosing instead to focus on providing an interoperable then method. Future work in companion specifications may touch on these subjects. Promises/A+ 规范主要是制定一个通用的回调方法 then，使得各个实现的版本可以形成链式结构进行回调。这使得不同的 Promise 库内部细节实现可能不一样，但是只有具有想通的 then 方法，返回的 Promise API 之间就可以相互调用。 下面会实现一个简单的 Promise，不想看实现的可以跳过。项目地址在这里，欢迎更多讨论。 Promise 构造函数，选择平台的 microtask 实现1234567891011121314151617181920212223242526272829303132// Simply choose a microtaskconst asyncFn = function() &#123; if (typeof process === 'object' &amp;&amp; process !== null &amp;&amp; typeof(process.nextTick) === 'function') return process.nextTick if (typeof(setImmediate === 'function')) return setImmediate return setTimeout&#125;()// Statesconst PENDING = 'PENDING'const RESOLVED = 'RESOLVED'const REJECTED = 'REJECTED'// Constructorfunction MimiPromise(executor) &#123; this.state = PENDING this.executedData = undefined this.multiPromise2 = [] resolve = (value) =&gt; &#123; settlePromise(this, RESOLVED, value) &#125; reject = (reason) =&gt; &#123; settlePromise(this, REJECTED, reason) &#125; executor(resolve, reject)&#125; state 和 executedData 都容易理解，但是必须要理解一下为什么要维护一个 multiPromise2 数组。由于规范中说明，每个调用过 then 方法的 promise 对象必须返回一个新的 promise2 对象，所以最好的方法是当调用 then 方法的时候将一个属于这个 then 方法的 promise2 加入队列，在 promise 对象中维护这些新的 promise2 的状态。 executor： promise 构造函数的执行函数参数 state：promise 的状态 multiPromise2：维护的每个注册 then 方法需要返回的新 promise2 resolve：函数定义了将对象设置为 RESOLVED 的过程 reject：函数定义了将对象设置为 REJECTED 的过程 最后执行构造函数 executor，并调用 promise 内部的私有方法 resolve 和 reject。 settlePromise 如何将一个新建的 Promise settled123456789101112131415function settlePromise(promise, executedState, executedData) &#123; if (promise.state !== PENDING) return promise.state = executedState promise.executedData = executedData if (promise.multiPromise2.length &gt; 0) &#123; const callbackType = executedState === RESOLVED ? \"resolvedCallback\" : \"rejectedCallback\" for (promise2 of promise.multiPromise2) &#123; asyncProcessCallback(promise, promise2, promise2[callbackType]) &#125; &#125;&#125; 第一个判断条件很重要，因为 Promise 的状态是不可逆的。在 settlePromise 的过程中假如状态不是 PENDING，则不需要继续执行下去。 当前 settlePromise 的环境，可以有三种情况： 异步延迟执行 settlePromise 方法，线程已经同步注册好 then 方法，需要执行所有注册的 then 回调函数 同步执行 settlePromise 方法，then 方法未执行，后面需要执行的 then 方法会在注册的过程中直接执行 无论执行异步 settlePromise 还是同步 settlePromise 方法，并没有注册的 then 方法需要执行，只需要将本 Promise 对象的状态设置好即可 then 方法的注册和立即执行1234567891011121314151617181920MimiPromise.prototype.then = function(resolvedCallback, rejectedCallback) &#123; let promise2 = new MimiPromise(() =&gt; &#123;&#125;) if (typeof resolvedCallback === \"function\") &#123; promise2.resolvedCallback = resolvedCallback; &#125; if (typeof rejectedCallback === \"function\") &#123; promise2.rejectedCallback = rejectedCallback; &#125; if (this.state === PENDING) &#123; this.multiPromise2.push(promise2) &#125; else if (this.state === RESOLVED) &#123; asyncProcessCallback(this, promise2, promise2.resolvedCallback) &#125; else if (this.state === REJECTED) &#123; asyncProcessCallback(this, promise2, promise2.rejectedCallback) &#125; return promise2&#125; 每个注册 then 方法都需要返回一个新的 promise2 对象，\b根据当前 promise 对象的 state，会出现三种情况： 当前 promise 对象处于 PENDING 状态。构造函数异步执行了 settlePromise 方法，需要将这个 then 方法对应返回的 promise2 放入当前 promise 的 multiPromise2 队列当中，返回这个 promise2。以后当 settlePromise 方法异步执行的时候，执行全部注册的 then 回调方法 当前 promise 对象处于 RESOLVED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。 当前 promise 对象处于 REJECTED 状态。构造函数同步执行了 settlePromise 方法，直接执行 then 注册的回调方法，返回 promise2。 异步执行回调函数12345678910111213141516171819function asyncProcessCallback(promise, promise2, callback) &#123; asyncFn(() =&gt; &#123; if (!callback) &#123; settlePromise(promise2, promise.state, promise.executedData); return; &#125; let x try &#123; x = callback(promise.executedData) &#125; catch (e) &#123; settlePromise(promise2, REJECTED, e) return &#125; settleWithX(promise2, x) &#125;)&#125; 这里用到我们之前选取的平台异步执行函数，异步执行 callback。假如 callback 没有定义，则将返回 promise2 的状态转换为当前 promise 的状态。然后将 callback 执行。最后再 settleWithX promise2 与 callback 返回的对象 x。 最后的 settleWithX 和 settleXthen123456789101112131415161718192021222324252627282930313233343536373839404142434445function settleWithX (p, x) &#123; if (x === p &amp;&amp; x) &#123; settlePromise(p, REJECTED, new TypeError(\"promise_circular_chain\")); return; &#125; var xthen, type = typeof x; if (x !== null &amp;&amp; (type === \"function\" || type === \"object\")) &#123; try &#123; xthen = x.then; &#125; catch (err) &#123; settlePromise(p, REJECTED, err); return; &#125; if (typeof xthen === \"function\") &#123; settleXthen(p, x, xthen); &#125; else &#123; settlePromise(p, RESOLVED, x); &#125; &#125; else &#123; settlePromise(p, RESOLVED, x); &#125; return p;&#125;function settleXthen (p, x, xthen) &#123; try &#123; xthen.call(x, function (y) &#123; if (!x) return; x = null; settleWithX(p, y); &#125;, function (r) &#123; if (!x) return; x = null; settlePromise(p, REJECTED, r); &#125;); &#125; catch (err) &#123; if (x) &#123; settlePromise(p, REJECTED, err); x = null; &#125; &#125;&#125; 这里的两个方法对应 Promise/A+ 规范里的第三章，由于实在太啰嗦，这里就不再过多解释了。 配合 async/await 使用更加美味V8 已经原生实现了 async/await，Node 和各浏览器引擎的实现也会慢慢跟进，而 babel 早就加入了 async/await。目前客户端还是用 babel 预编译使用比较好，而 Node 需要升级到 v7 版本，并且加入 --harmony-async-await 参数。 Promise 其中的一个局限在于：所有操作过程都必须包含在构造函数或者 then 回调中执行，假如有一些变量需要累积向下链式使用，还要加入外部全局变量，或者引起回调地狱，像这样。 1234567891011121314151617181920212223242526272829303132333435363738let result1let result2let result3getSomething1() .then((data) =&gt; &#123; result1 = data // do some shit with result1 return getSomething2() &#125;) .then((data) =&gt; &#123; result2 = data // do some other shit with result1 and result2 return getSomething3() &#125;) .then((data) =&gt; &#123; result3 = data // do some other shit with result1, result2 and result3 &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;)getSomething1() .then((data1) =&gt; &#123; // do some shit with data1 return getSomething2() .then((data2) =&gt; &#123; // do some shit with data1 and data2 return getSomething3() .then((data3) =&gt; &#123; // do some shit with data1, data2 and data3 &#125;) &#125;) &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;) 引入了全局变量和写出了回调地狱都不是明智的做法，假如用了 async/await，可以这样： 123456789101112async function a() &#123; try &#123; const result1 = await getSomething1() // do some shit with result1 const result2 = await getSomething2() // do some other shit with result1 and result2 const result3 = await getSomething3() // do some other shit with result1, result2 and result3 &#125; catch (e) &#123; console.error(e); &#125;&#125; async/await 配合 Promise，没有了 then 方法和回调地狱的写法是不是清爽了很多？ 结语本文后续其实还有更多值得挖掘的地方： 如何更加有效地选取平台的 microtask？ 如何实现一个可用的符合 ECMAScript 规范的 Promise？ microtask 和 task 在 event loop 具体的执行过程？ 可以期待后续的更多内容。最后再贴一下项目地址，欢迎继续的讨论。 参考资料 asap github setImmediate github yaku github 剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}],"tags":[],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}]},{"title":"理解比特币原理","slug":"2016-09-11-理解比特币原理","date":"2016-09-11T10:50:07.000Z","updated":"2016-10-15T01:15:51.000Z","comments":true,"path":"2016/09/11/2016-09-11-理解比特币原理/","link":"","permalink":"https://ftandy.com/2016/09/11/2016-09-11-理解比特币原理/","excerpt":"对于比特币原理的分析，无论是 wiki，论文，知乎，博客上，有非常多的文章写得非常好。这篇文章只是我看了很多相关文章之后的个人总结，对于需要理解比特币的同学可能可以提供一些帮助。","text":"对于比特币原理的分析，无论是 wiki，论文，知乎，博客上，有非常多的文章写得非常好。这篇文章只是我看了很多相关文章之后的个人总结，对于需要理解比特币的同学可能可以提供一些帮助。 本文只是解释比特币的原理，关于比特币的其他方面：成因，应用，现状，安全等等话题都不深入解释。 先从几个核心特性去了解比特币 最基本的公钥私钥体系每个人都可以利用现有的签名算法来生成属于自己公钥私钥，不同的签名算法有不同的特性。私钥自己保管，公钥可以广播到网络。信息可以通过私钥进行加密，然后通过公钥解密，也可以通过公钥加密，私钥解密。比特币中生成秘钥使用的是 ECDSA 签名算法。 由于公钥私钥的特性，在比特币体系中，用公钥私钥作为记录交易信息的工具。当 A 向 B 支付一笔钱的时候，A 将 B 的公钥和这一笔钱的信息用私钥加密，并传给 B。B 得到这个信息后，用 A 的公钥解密，得到“A 向 B 支付一笔钱”的信息。这时候 A 和 B 的帐目上都有了“A 向 B 支付一笔钱”的信息。 这个利用公钥私钥加密解密过程，是比特币交易过程的最基础的一个环节。 比特币 p2p 网络去中心化系统当多个人想要参与到交易当中的时候，交易过程的记录就没那么简单了。 每个人都有自己的交易，而且每个人都需要对每个人的交易的进行记录。这个时候需要一个广播系统把新的交易记录广播到其他人的帐目中。 当 A 向 B 发送交易信息的时候，会向周围的 p2p 节点也广播交易信息，各节点会用 A 的公钥验证 A 发送的这条信息是否为真，然后检查当前帐目当中 A 是否有这么多钱。最终当足够多节点都确定这条信息为真时，整个比特币系统就确认这条交易信息为真，并记录在各个节点的帐目当中，并广播到其他未收到该交易记录的节点。最后，在整个 p2p 节点系统中，B 用可以用“A 向 B 支付一笔钱”这条交易信息，使用 A 发送过来的钱在比特币系统中使用了。 其实，在整个比特币系统（或者说 p2p 网络）当中，并没有记录任何一笔钱属于谁，有的只是一笔笔交易记录，然后推算出 A 当前有多少钱，B 当前有多少钱。这只是一个广播和管理帐目的的系统，任何人安装了标准客户端，都可以下载历史上每一笔交易记录。没有任何一个中心节点或者服务器，所以说整个比特币系统是去中心化的 p2p 系统。 区块链（chain of block）和挖矿（mining）在整个 p2p 系统中，如何管理这么多交易记录是一个问题。 区块链（chain of block）就是解决管理交易记录的。历史上每一条交易都存在一个 block 中，后建的 block 基于前一个 block 建立。新 block 包括了新增的大量交易记录信息和前一个 block 的 id（每个 block 的 id 为前一个 block 的 hash 码的 hash 码）。所以称为 chain of block。 当有新的交易记录产生时（可能同时间非常多），本地节点会向周围的节点发送这条交易信息。由于这些交易信息在整个系统中没有认证过，所以需要有节点对这些新的交易记录进行认证，并负责向其他节点广播。 但是得到认证资格是一件很麻烦的过程。首先需要用公钥验证是否为真，然后遍历所有的历史帐目，计算出交易者的帐面余额。假如余额足够，交易信息有效，则取出上一个 block 的 id，然后将刚刚本节点所有认证过的新的交易记录整合在一起，作一次 hash 运算，假如 hash 出来的值符合系统规定的格式，才算得到了认证资格，这才有资格将制造出的新 block 广播出去。假如计算出的 hash 没有符合，对不起，请重新计算，把最新的交易信息再整合一次，按照算法再算一遍，如此循环。 因为想要计算出符合系统规定格式的 hash 非常困难，所以这个制造新的 block 的过程叫做挖矿（mining）。假如挖矿成功，将新的 block 连到整个区块链上并广播出去的同时，都有机会制造出一条系统给自己 50 比特币的交易记录（最初是50，现在2016年是25）。但是每制造出 210000 个 block，挖矿奖励就会减少一半，最终所有比特币的总量是2100万个比特币。 比特币就是这么一个，以公钥私钥，区块链，挖矿为基础，组成的 p2p 广播系统。但是有更多有趣的问题可以深入探讨，本文就不多探讨了。想要探讨更多请点击下面的链接。 问题xxxxx 参考链接 比特币的价值探讨——byvoid Bitcoin 的基本原理——云风 bitcoin的技术原理——zhiqiang","categories":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://ftandy.com/categories/bitcoin/"}],"tags":[],"keywords":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://ftandy.com/categories/bitcoin/"}]},{"title":"论2009电竞职业发展，和成功互联网开发者职业发展的相同","slug":"2016-09-10-论打电竞职业与互联网职业的相同","date":"2016-09-10T14:26:03.000Z","updated":"2016-09-19T14:21:38.000Z","comments":true,"path":"2016/09/10/2016-09-10-论打电竞职业与互联网职业的相同/","link":"","permalink":"https://ftandy.com/2016/09/10/2016-09-10-论打电竞职业与互联网职业的相同/","excerpt":"最近我在看 panda tv 的 pandakill 直播，这是一个 panda tv 主持，安排自己平台上的各电竞明星主播一起玩狼人杀的节目。节目本身非常精彩，效果也非常爆炸。 我是由于2009在微博上发声，我才发现发现的这个节目。 这里先抛开这个题目：《论2009电竞职业发展，和成功互联网开发者职业发展的相同》中的后一段，先介绍下我以前的偶像，如今的人生赢家和成功商人2009。","text":"最近我在看 panda tv 的 pandakill 直播，这是一个 panda tv 主持，安排自己平台上的各电竞明星主播一起玩狼人杀的节目。节目本身非常精彩，效果也非常爆炸。 我是由于2009在微博上发声，我才发现发现的这个节目。 这里先抛开这个题目：《论2009电竞职业发展，和成功互联网开发者职业发展的相同》中的后一段，先介绍下我以前的偶像，如今的人生赢家和成功商人2009。 在许多电竞职业玩家和我们普通玩家眼中，2009是一个真真正正的人生赢家。我也是算用自己的青春（2009年我高一，刚好开始玩 dota）来见证了2009的成功过程。 2009大学的时候由于热爱 dota 和电子竞技，在校期间成为 dota 路人王。在国内电子竞技还没有成型的情况下，毅然放弃了浙大的学业（后来回学校拿到学位），投入到了 dota 的职业圈当中，在职业开始的几年内以个人强大的实力加入了知名战队 Ehome，然后又成立自己的战队 FTD，之后扫了国内外大大小小的冠军。然后以自己的名气做了 dota 从零单排的系列视频，成为各个网友，菜鸟（像我）崇敬的对象。那时候开始被网友尊称为大酒神，创世神。每一局游戏都要以自己的大菊观，不能忍解说自己的从零单排视频，带领一群菜鸟走向胜利。后面由于有了视频的名气和大量点击率，做起了淘宝店主，专卖零食和猪肉粒，再被网友冠民猪肉酒。可能由于发现自己职业能力的下降，而淘宝的利润和市场巨大，毅然放弃了职业，用自己的名气专门做起了视频解说和淘宝，成为 dota 圈中职业转淘宝解说的第一人。后来遇到手游市场的兴起，自己办了手游公司，成功登上 CEO 的宝座。现在仍然以自己的名气做 dota 视频和直播，卖淘宝，运作公司，年薪千万，可以成功完成了职业选手到商人的转型。 我可以说2009的智商和情商都非常的高（考上浙大不是白扯的啊），在自己职业道路发展受阻的情况下，看准时机做起视频，以人气为资本做起了淘宝生意，还成立了公司。在电竞圈中，即收了名，也收了利，也算是前无古人，后无来者了。 这里我将2009的成功过程分为4个阶段： 年轻有实力成为路人王，进入电竞圈，加入知名战队，横扫冠军 以自己的冠军和战队名称做起从零单排视频，以自己的经验收获大片网友关注度，然后开始向淘宝卖家转型 职业发展缓慢，职业选手的淘宝卖家市场还没有开发，发现巨大商机，毅然放弃职业，全身心做起视频解说和淘宝，收获巨大利润。 以自己的名声和巨大利润为基础，迎合当时的手游市场的兴起，做起了游戏和视频公司，成为一个成功的商人。 现在说回那晚看完 pandakill，我认真分析了一下2009这个人，发现2009的成长轨迹跟我在网上看到的很多成功的开发者非常相似。 这里我也将成功的开发者成功的过程分为4个阶段： 名校 CS 相关专业毕业，成为同年龄段开发者中的佼佼者，以强大的技术能力加入大公司，开发着大公司内成功的产品 以自己的实力和大公司的名气，在 github 上开源技术和代码收获大片入门和基础开发者的关注度 以自己技术圈内的人气和实力，在业余开发出一个逮住某个商机和市场的产品，跳出大公司开发自己的产品 成立自己的公司，晋升 CEO，成为一个成功的商人 对比之后发现：电竞选手职业发展与开发者职业发展确实非常相同。 这里我只是突然联想，一时脑热，写下了这篇文章。按2009的职业发展与一些成功的开发者作了单一的对比，发现一些相似的地方。但是有很多成功的电竞职业选手和成功的开发者都不是按照上面这条路来走，也可以非常成功。其他的就不一概而论了。","categories":[{"name":"dota","slug":"dota","permalink":"https://ftandy.com/categories/dota/"}],"tags":[],"keywords":[{"name":"dota","slug":"dota","permalink":"https://ftandy.com/categories/dota/"}]},{"title":"Sharedb 源码分析(待续)","slug":"2016-05-15-Sharedb-源码分析","date":"2016-05-14T16:34:19.000Z","updated":"2016-08-23T10:26:15.000Z","comments":true,"path":"2016/05/15/2016-05-15-Sharedb-源码分析/","link":"","permalink":"https://ftandy.com/2016/05/15/2016-05-15-Sharedb-源码分析/","excerpt":"入坑原因和暂时弃坑原因之前帮一个公司做一个关于文档实时共享和编辑的项目，项目性质类似于 quip 和 google doc，核心功能使用到一个叫 sharejs 的库。 由于这个项目实时功能很强大，但是文档少而且很旧，所以想要深入了解一下内部原理，需要分析一下源码。此为背景，也为入坑原因。 但是！在读源码的时候，了解了一下这个项目的背景，发现坑有点深。 这个项目原本是被集成到一个叫 DerbyJS 的框架中（类似于 meteorjs 的实时通讯框架）和作为一个叫 Lever 硅谷公司的核心库，但是作者之前一段时间离开了这家公司，和由于一些私人原因放弃管理了这个项目很久，issue 一大堆，邮件列表不回复，所以项目一团糟。现在 sharejs 已经不维护，但是分出一个 sharedb 的项目，让 Lever 的 CTO 来管理，作者也在干自己的事没有管，那个 CTO 也是忙着管理公司，所以结果就是开发进度极慢，文档几乎没有，极少人关注这个库。 因为自己要忙找工作和毕业的事，所以把写到一半的笔记放下来，等以后有这个时间再继续研读源码，把这个坑填起来。","text":"入坑原因和暂时弃坑原因之前帮一个公司做一个关于文档实时共享和编辑的项目，项目性质类似于 quip 和 google doc，核心功能使用到一个叫 sharejs 的库。 由于这个项目实时功能很强大，但是文档少而且很旧，所以想要深入了解一下内部原理，需要分析一下源码。此为背景，也为入坑原因。 但是！在读源码的时候，了解了一下这个项目的背景，发现坑有点深。 这个项目原本是被集成到一个叫 DerbyJS 的框架中（类似于 meteorjs 的实时通讯框架）和作为一个叫 Lever 硅谷公司的核心库，但是作者之前一段时间离开了这家公司，和由于一些私人原因放弃管理了这个项目很久，issue 一大堆，邮件列表不回复，所以项目一团糟。现在 sharejs 已经不维护，但是分出一个 sharedb 的项目，让 Lever 的 CTO 来管理，作者也在干自己的事没有管，那个 CTO 也是忙着管理公司，所以结果就是开发进度极慢，文档几乎没有，极少人关注这个库。 因为自己要忙找工作和毕业的事，所以把写到一半的笔记放下来，等以后有这个时间再继续研读源码，把这个坑填起来。 以下为源码阅读笔记 Client 部分使用 websocket 或者 browserchannel(long polling) 实时通讯的方法，在 client 初始化，与服务器形成通信渠道，并让 sharedb 对象注册该通讯方法。 websocket 和 browserchannel 用了 w3c 规定的 websocket 回调函数接口：onopen, onerror, onclose, onmessage。当建立起通讯的时候回调 onopen，有信息来的时候回调 onmessage，错误信息回调 onclose，关闭通讯回调 onclose。 connection 对象 mixing 了 event emitter，可以自定义 emit 和相对应的 once。 初始化一个 connection 对象会绑定对应的 socket 对象（websocket 或者 browserchannel），并且定义好 client 端对 socket 的四个回调函数：onopen, onerror, onclose, onmessage。 在通讯的过程中，有四个状态： ‘connecting’: The connection is still being established, or we are still waiting on the server to send us the initialization message ‘connected’: The connection is open and we have connected to a server and recieved the initialization message ‘disconnected’: Connection is closed, but it will reconnect automatically ‘closed’: The connection was closed by the client, and will not reconnect ‘stopped’: The connection was closed by the server, and will not reconnect doc 部分，分为 collection 和 docs，一个 collection 由多个 doc 组成，一个 doc 有自己的初创 id。 当 doc 需要 subscribe 到 server 的时候，会发送 subscribe 的动作和注册的 doc 名称。假如该文档没有 Server 部分server 可以绑定 mongo 或者 redis，或者不绑定，直接使用 memory，作为 doc 的数据暂存方法。 每当一个 client 初始化一个 socket，server 也会初始化一个对应的 client/session，这个 client/session 会对应上sharedb 的 agent。 server 会在每次会话定义一个 stream。sharedb 会将这个 stream 注册到 backend 对象中，并对应初始化一个 agent。初始化时，会向 client 发送确认初始化的信息，触发 client 的 onopen 事件。当有一端的 client 有动作并发送信息时，server 会以 stream 的形式读入该 client 的动作，并保存动作和版本号在 doc 对象当中，并向其他 subscribe 过的 agent 通过 socket 发送改动作信息。 库hat: 随机数生成，随机一个 client/session id https://github.com/substack/node-hat asyn: 异步函数集合 https://github.com/caolan/async stream: 处理数据输入输出流 https://nodejs.org/api/stream.html https://github.com/jabez128/stream-handbook ps: readable 读出时，用 on(‘data’)事件监听数据，用 _read 函数对读出的数据进行数据格式化。writeable 被写入时，可以定义 _write 函数定义当有数据读入时，该如何处理数据。所以 sharedb 监听一个 stream ，当 backend 有操作的时候，会向该 stream 写入信息，然后该 stream 再触发 ws/browserchannel 的接口向客户端发送信息。 browserchannel: 基于长轮询的持久通讯 https://github.com/josephg/node-browserchannel ws: 与 browserchannel 基本上有相同的开发 api，可以被 sharedb 使用 https://github.com/websockets/ws arraydiff: 显示数组之间的差异 https://github.com/derbyjs/arraydiff deep-is: 比较数据是否全等 https://github.com/thlorenz/deep-is 源文件backend.js: 整个初始化的 backend，自服务器监听以后一直存在于 server，每当有一个新的 client 建立，都会对应建立一个新的 stream 监听到 backend，并创建一个新的 agent，并发送确认信息到 client， agent.js: 解析 stream 中的写入信息，在 agent 触发相应的函数，使用 value 来返回。agent 变量在 server 端对应于 client 的一个 subscirbe。agent 会使用 _handleMessage 函数接收回来的动作并执行对应的私有函数 types.js: 注册默认ot类型，记录在 map 里。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}],"tags":[],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}]},{"title":"Ode on Solitude","slug":"2016-05-14-Ode-on-Solitude","date":"2016-05-14T06:36:06.000Z","updated":"2016-10-27T13:27:12.000Z","comments":true,"path":"2016/05/14/2016-05-14-Ode-on-Solitude/","link":"","permalink":"https://ftandy.com/2016/05/14/2016-05-14-Ode-on-Solitude/","excerpt":"","text":"Happy the man, whose wish and careA few paternal acres bound,Content to breathe his native air,In his own ground. Whose herds with milk, whose fields with bread,Whose flocks supply him with attire,Whose trees in summer yield him shade,In winter fire. Blest! who can unconcern’dly findHours, days, and years slide soft away,In health of body, peace of mind,Quiet by day, Sound sleep by night; study and easeTogether mix’d; sweet recreation,And innocence, which most does please,With meditation. Thus let me live, unseen, unknown;Thus unlamented let me die;Steal from the world, and not a stoneTell where I lye. Alexander Pope Ode on Solitude 耕作着祖辈留下的几亩土地，呼吸着土地上自然的空气这样的人才能称为快乐的人 牛产牛奶，地长面包羊毛身上穿树阴为他留，冬天有柴烧 真是太幸福了无忧无虑地过着轻松，快活的日子身体健康，头脑清晰，悄悄过着小日子 睡觉打着鼾，闲时读些书张弛有度，酣畅淋漓天真时感到快乐，快乐时又带着沉思 无名，无声地活着没有遗憾地死去不留下任何痕迹，悄悄离开这个世界 Alexander Pope Ode on Solitude","categories":[{"name":"poem","slug":"poem","permalink":"https://ftandy.com/categories/poem/"}],"tags":[],"keywords":[{"name":"poem","slug":"poem","permalink":"https://ftandy.com/categories/poem/"}]},{"title":"理解 HTTPS 的安全性","slug":"2016-03-29-HTTPS","date":"2016-03-29T13:36:44.000Z","updated":"2016-04-27T08:39:13.000Z","comments":true,"path":"2016/03/29/2016-03-29-HTTPS/","link":"","permalink":"https://ftandy.com/2016/03/29/2016-03-29-HTTPS/","excerpt":"受到这篇对 HTTPS 的加密过程讲得非常通俗浅显的文章的启发，想自己找些资料宏观上再总结一下 HTTPS 的加密过程，加强对 HTTPS 的理解。","text":"受到这篇对 HTTPS 的加密过程讲得非常通俗浅显的文章的启发，想自己找些资料宏观上再总结一下 HTTPS 的加密过程，加强对 HTTPS 的理解。 想要理解 HTTPS 加密。需要理解几个概念： 对称加密算法 非对称加密算法 CA(Certificate Authority) 数字证书 摘要算法 现在的问题是，如何在实现 HTTP 协议的情况下，对传输的信息进行加密解密？最开始使用到的是最简单的对称加密算法。 对称加密算法对称加密算法非常简单，只要加密方和解密方都拥有同一密钥（可为128，192，256 bit 大小的密钥，密钥越长，加密解密时间越长，解密难度也越高），即可完成加密解密过程，且假设无法强制对加密过的明文进行解密。 问题：对于需要传递加密信息的双方而言，对称加密算法用于加密解密没有什么问题，但是密钥的传输就成了另外一个问题。因为密钥也需要传输才能使双方通信，密钥明文传输出去，被人轻易截取，就能利用密钥破解加密的密文。所以引出了下面的非对称加密算法来传输密钥。 公开密钥加密(Public-Key Cryptography)的非对称加密算法对于使用最广泛的非对称加密算法——RSA，RSA 算法基于一个简单的数论理论：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA 算法得出了下面的规则：通讯两方 A, B 分别都有各自的一套公钥和私钥。同一套公钥私钥当中，公钥的加密需要私钥才能解密，私钥的加密需要公钥才能解密。 假设 A 把自己的公钥公开出去，B 得到了 A 的公钥，然后 B 用 A 的公钥加密了明文，传给 A，A 用私钥解密，即可获得明文。所以，过程中公开的信息任何第三方得到都不可以破解 A 和 B 要传递的信息。有了这个算法之后，对称加密算法所用到的密钥传输安全性就没问题了。但是因为加密解密过程时间比较长，非对称加密算法不适合应用于数据量大的信息传递，只适用于密钥的传递。（这个问题解释了对于数字签名的摘要算法的必要性） 问题：虽然 RSA 算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。在用非对称加密算法传递密钥的过程中，因为公钥都是公开的，并没有任何东西可以认证这个公钥是 A 的还是 B 的。现在出现了中间人 M，M 采取某种手段在 A 和 B 的通讯过程成为中间人。在 B 想要得到 A 的公钥的时候，M 向 B 谎称自己的这个公钥是 A 的公钥，B 拿到用 M 的公钥加密信息后，传出 M 手中，然后 M 拿加密过的信息，然后用自己的私钥把这个信息解密，得到明文。既然已经知道了明文，还是用 A 的公钥加密这个信息，继续给 A，这样 A 还是以为这个信息是安全的，继续用私钥解开。而在这个过程中，M 既获得了信息，又没有让 A，B 双方知道。至于这个 M 是怎么欺骗 A，B 的，又是另外一个安全的问题。总之，假如 M 只要让 B 相信这个公钥是 A 的，就可以作中间人攻击。 假如上面的 A 是服务器，B 是用户，那么中间人就很容易获取和修改 A，B 需要传输的信息。所以为了让 M 不再得逞，出现一个具有公信力的第三方——CA。 CA(Certificate Authority) 第三方认证机构简单来说，CA 要做的就是，让 B 相信拿到的 A 的公钥真正属于 A，而不是其他中间人 M 伪造。 而在 CA 在做这件事的过程中如何才能让 B 认证这个公钥是 A 的呢？ 这里需要另外一个概念：数字证书。 普通证书产生的过程就是：将个人提交的信息进行第三方具有权威性部门的认证，然后第三方权威部门确认个人信息合法无误后在自己的系统中登记，再把认证证书盖章签名给到个人手上，然后个人就可以用证书从事各类证明活动。现实世界中的做法是在个人提交的信息上盖章，例如4，6级的证书认证。假设你的成绩申请无误而合法，教育局就会将你的成绩记录，然后给你一张盖过章的证书。 数字证书同理。不过，与现实不一样，在互联网上完成一个完整的验证过程，需要兼顾到很多过程中的纰漏。 例如： 问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？现实中就是向政府部门认证哪些是登记过的可信任的部门，像4，6级证书颁发的部门——全国大学英语四六级考试委员会，是全国的教育局的下级和内部部门，是认证过的。而在互联网中，就需要顶级的最具有公信力的 CA，这个 CA 颁发的证书是最受信任的，这个就是根证书。为了不让所有鸡蛋都放在一个篮子里，其他的 CA 机构可以向上一级的 CA 机构申请成为中间 CA，获取自己的中间证书，最终个人像 A 向某一个中间 CA 申请的证书就是最终的终端普通数字证书。这个过程的签发关系就是证书链。当 B 得到 A 的数字证书之后，会在证书的信息中找到 A 申请的 CA，而这个 CA 则会根据自己中间证书找到的自己申请的 CA，就这样沿着证书链找证书，假如某个中间证书或者根证书在本机中安装有，则认证的时候会将 A 的证书设置为可被信任的。 如何识别可信任机构的这个问题就解决了。 问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？现实中可以在这个已经被认证的第三方机构系统中查询，像4，6级，可以到教育局的网上公开系统中查询。而在互联网中，则需要一个类似的查询验证过程——数字签名。为了对这个证书的验证，确保这个签名是来自可信任的 CA，而不是其他不可信的 CA。CA 在给 A 的数字证书中有一个数字签名。该签名是 CA 用自己的私钥对 A 的个人信息进行非对称加密得到的加密信息。当 B 得到 A 提供的数字证书，会拿到其中的数字签名和 A 的个人信息，然后用 CA 的公钥对这个数字签名进行非对称解密，得出的信息假如和 A 的数字证书中 A 的个人信息一样的话，就相信这个数字证书确实是 CA 认证过的。 如何认证这个签名是不是伪造的这个问题也解决了。但是这个问题又引出了另外一个问题：数字证书中 A 的个人信息数据比较大，而非对成加密算法的加密解密速度非常慢，使得认证过程中对个人信息的非对称加密解密非常耗占时间。所以需要用到另外一种算法来加快这个验证过程，这个算法就是摘要算法。（一直很疑惑为什么需要到摘要算法，总算找到了一个原因） 摘要算法可以将任意大小的原文消息加密并摘要成固定长度的简短密文。对于不同的原文消息，用同一种摘要算法，都可以得到不同但是固定长度的密文，而相同的原文消息，用同一种摘要算法，则可以得到相同固定长度的密文。这就解决了数字签名过程中，对数据大的个人信息文件的非对称加密解密的时间慢的问题。CA 用 A 个人信息进行摘要算法的处理，然后继续用私钥加密，作为数字证书的数字签名给到 A。B 拿到 A 提供的数字签名和 A 的个人信息，然后用 CA 的公钥解密 A 的数字签名，得到 A 个人信息的摘要。再用同一种摘要算法对 A 的个人信息进行处理，得到 A 个人信息的摘要，再与解密得到的 A 个人信息摘要对比，就可以确认改数字签名和个人信息是匹配的。 到这一步，中间人攻击已经很难可以发生了，假设 M 想要在 A 和 B 之间充当中间人，有三种手段： 需要从 A 服务器中直接获取域名数字证书； 得到 A 的域名管理，向 CA 申请证书 自己签发证书，然后要求 B 安装自己的证书。 对于第一第二个问题的防范，在服务器端，只要要保护好私钥和服务器和域名的安全，就不会出现大问题。 对于第三个问题，在客户端，有一个很好的例子：12306。12306 的证书就是中铁局自己搞的认证机构颁发的。当你浏览 12306 的时候，虽然请求是带 HTTPS，但是浏览器检查的时候发现这个中铁局的认证机构没有在证书链当中，会提示“可能会被攻击”，当然 12306 会要求你直接安装他们的证书。这就要求你自己的明察秋毫了，你是选择相信 ZF 的证书，然后可能以后 ZF 的某些网站可能会在中铁局的认证机构认证证书，然后假装是 HTTPS，并且可能会伪装窃取你的个人信息。所以在客户端，安装证书需要谨慎，不要随意安装不信任的证书。 下一篇文章应该会讲一下如何用 letsencrypt 在服务器给域名加上 HTTPS 的问题。 PS: 本博客就是用的 letsencrypt。 原文链接：https://www.ftandy.com/2016/03/29/HTTPS/ 参考资料 HTTPS 是如何保证安全的？ 详解https是如何确保安全的？ 数字证书的基础知识 SSL教程：什么是SSL证书链？ 三种解密 HTTPS 流量的方法介绍","categories":[{"name":"https","slug":"https","permalink":"https://ftandy.com/categories/https/"}],"tags":[],"keywords":[{"name":"https","slug":"https","permalink":"https://ftandy.com/categories/https/"}]},{"title":"认识黑化的自己","slug":"2016-03-28-decadent","date":"2016-03-28T12:46:16.000Z","updated":"2016-04-07T13:51:55.000Z","comments":true,"path":"2016/03/28/2016-03-28-decadent/","link":"","permalink":"https://ftandy.com/2016/03/28/2016-03-28-decadent/","excerpt":"2015下半年，大四上学期，我患了抑郁症，荒废了大四的半年时间。","text":"2015下半年，大四上学期，我患了抑郁症，荒废了大四的半年时间。 心理医生在北京实习的时候我曾经去看过心理医生，那时候还不知道自己是抑郁，只是以为自己心理上可能有些小问题，一直以来也想了解下去看心理医生是什么体验。但是整个一小时咨询过程对我来说是一点用都没有。两个人在一个比较安静的房间，心理医生就是坐在那里一直问你：你现在的感觉什么样？说出你生活当中纠结的地方？WTF！这还不如跟一个熟悉自己的朋友聊天或者自己写博客，至少我能躺开心扉说出任何东西，跟一个他能说什么？或者因为我报的是400块/小时的，医生不是很合格吧。但是完全对我没有任何帮助这一点是毫无疑问的，更甚还让我更加纠结。 纠结和个人信念最近我才开始理清楚一直在纠结的东西。 从小以来对于个人成长，我的信念都是：一个正常的人被生下来，应该受到正常的来自父母的爱，社会的爱，然后利用这些爱的力量健康地成长，成长后再为家庭为社会做一些事情，散发自己的力量和爱。 但是随着自己的阅历增长，特别是走出自己的小城，上大学，然后来到大城市工作之后，发现对于很多类似我家庭背景的人来说，并不是这样。当自己在社会上看到越来越多身边的人表面上都有一个正常的家庭的时候，自己就会安慰自己说：没有什么，即时自己没有来自家人的爱，我也能成长得很好，也能有一番成就。但是最终做事情的时候，内心深处黑暗那些声音还是会在生活上的细节打败自己，跟自己说，我的父母不爱自己，他们不需要我，我为了什么而活？假如我是被抛弃的，那活在这个世界就是一个错误，我本不该出生。这个想法一度在我成长的心中占领很大的位置。 个人的源动力和内心的黑暗面每个人每做一件关键的事，总会找到最终的根原因，一个心中的正能量，一个纯粹的动机，一个寄托去激励着自己每天都健康地生活成长。但是我没有。家庭？社会？朋友？最终面临的还是自己的欲望，既然没有人期待我去做这件事，那我就按自己的本性做得自己就好了。这就是自我自私，贪婪，懒惰等人性阴暗面面滋生的开始。假如人成长过程中，内心深处没有来孕育出一种来自外部的爱，鼓励和责任的力量，凭着自己生物性质的自利欲望思想，很容易在生活中失败和犯下很多错误。 从小到大，我没有过来自父母的爱，生活学习都是亲戚朋友零零星星的施舍，一直都在被抛弃的状态。我以为这个问题没有什么，但是越长大越遇到一些重要的决定的时候，回顾起这个问题，我才发现这个问题需要给自己一个最终解答。假如始终找不到自己的生活中的一个根，试问我自己该如何才能去做到像我身边那些健康成长的孩子一样成功优秀？难道忍着这个心理的痛苦去不断地努力，一直去做事，掩盖着事实，心里还是一直在滴血，然后最后有点成绩之后才跟自己说，其实这样就行了，就这样吧。 累积和爆发我知道自己可以做到更好，但是我没有选择去做，因为这个问题孕育出来的阴暗品质累积起来对我影响太大，一些内心的阴暗面开始展现出来。假如我只为自己活，为什么要去那么辛苦呢？轻松一点，平庸一点不就行了吗？既然这个问题没有什么紧要，迟一点完成不就行了吗？非常多生活上的小问题都会被影响，累积起来的小问题导致了我大四最终由于发现太多小问题解决不了而爆发了，想要彻底放弃自己，还产生过自杀的想法。那种状态就像做梦的时候知道自己正在做梦，但是一直叫不醒自己，抑郁得让自己窜不过气。 我那时候发过一条微信：自己大半年没有跟家庭联系，才真正叫过生活呢。我知道自己一直想要获得更多来自家庭的动力，来自家庭的爱，或许是我认清了自己已经成长到可以独立，再也无法苛求太多来自家庭的东西了。遗憾和失落达到了最高点，才放弃了生活。我也知道那段时间自己有很多问题需要解决，但是内心深处就是一直抵抗去解决。从小的希望破灭，亦无欲望再生活下去。那段时间的生活真是惨不忍睹。 从小到大，当我有时候很认真地对解决完一个问题，很想去跟别人分享自己的感受的时候，发现自己父母不了解自己，甚至不会想跟自己有关系。心中真的很难过。假如我真的在未来由于更大的原因自杀了，我真的要感谢我的父母，是他们一直都在忽视我，给了我放弃生活的理由。 为何他们在我面前却不理我？假如这样为何不直接抛弃我，送我到孤儿院，或者在我出生时直接扼杀我？最可恶的不是他们直接抛弃我，而是在我跟前看着我思想上在腐烂在死亡，而在旁边什么都不做。这种感觉，一直在我的童年中持续，而我一直在用其他事情在加以掩盖，相信着这个不是我个人的问题。现在我要把它拿出来，把心中最腐烂的东西给自己看清，跟自己说这才是自己心中的心病。 觉悟而且最近想得多会觉得，其实纠结过多干什么，既然家庭不需要自己，我也不必要去为他们完成点什么。做事基于自己的认知原则去做就好了，反正自己已经有独立意识和学习能力了，也有能力独立生活了，也没有必要过于纠结以前的羁绊。以前的事虽然是自己身上的一个苦痛印记，但是接下来的那几十年的路还是要自己走啊，过于纠结只是在糟蹋自己的生命，世界这么大，还容不下我去生活？ 未来我总是写一些比较具有负能量，探讨自我的文章，因为我想自己变得更好，既然身边没有资源给我利用，我就利用自己好了，写文章给自己看，作为自省的一个途径。 更多地去写作，去学习，去认知这个世界，继续去找到激励自己去更好生活的原因。我想，这篇文章之后，我也不会再过去地去纠结自己的家庭问题了吧，反正自己跟自己把一些都说清了，也没有什么好纠结了。继续航行吧。","categories":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}],"tags":[],"keywords":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}]},{"title":"2015","slug":"2016-02-20-2015","date":"2016-02-20T09:57:34.000Z","updated":"2016-02-20T10:03:41.000Z","comments":true,"path":"2016/02/20/2016-02-20-2015/","link":"","permalink":"https://ftandy.com/2016/02/20/2016-02-20-2015/","excerpt":"2015有些话要说2015年，一半努力，一半颓废。","text":"2015有些话要说2015年，一半努力，一半颓废。 自大二开始发现自己家庭已经破败，想要完全抛弃家庭，在外面独立生活，却在社会上没有自我生存能力的时候，才觉得自己应该有一项必要的生存技能。高考至大一大二自己也从来没有想过要当一名程序员，只是因为自己爱玩电脑游戏，想要沉浸在电脑的世界里才报的计算机专业。高考失败引领的垃圾大学教育，没有教到我任何东西，也没有激发起太多我对计算机的兴趣。大二下的时候，也是有点愤慨，看了很多知乎上程序员写的个人成长经历鸡汤，才呆萌地开始在网上开始寻找相关的知识学习。万事开头难，忘了那时候是什么阴差阳错，接触到了 Rails，然后大二下学期厚着什么都不懂的面皮去了深圳一家外包公司当苦力。从大二暑假开始一直干到大三的下学期。这段时间暂时有了自己的生计，解决了自己的生活的同时，利用多余的钱勉强买了一台 Mac Pro 和 iphone 5s，入了苹果神教，并抛弃了神船。也是对自己实习期间的工作有了一个小小的交待。而后又到投了许多上海和北京的简历，这时候却因为自己的能力有限，只投了一些小公司，不敢投大公司。面了几家，因为自己有一点的实习经历，还是有一些给了我 offer，也累计了一些的面试经验。最后暑假去了北京的一家创业公司，干了3个月，也接触到了很多前端和 Node.js 方面的技术知识。回到学校后，却又有些迷茫，不知道下一步该怎么去做。学校的垃圾课不想去上，自学但又没有毅力学太多；发现身边的人几乎没有相似的经历和想法，无法沟通；一直没有平衡好写代码和平时生活，生活极其不规律，甚至对写代码有些厌倦排挤。还有其它种种因素，使我不想要去管自己的生活，轻易地一头掉进了 dota 的世界，失去了理智的生活。自大四开始，虽然也接过一些工作，但是颓废的生活一直持续了一个学期。直到最近一个月，回到小城，才找回了一些理智，开始找一些兼职。也开始收拾起心情找一些工作和思考一下未来，毕竟大四了，也要找一份稳定的工作，对自己有一个交待。 这就是自己的2015，没有多少精彩，多的只是颓废和遗憾。其实我也没有多少遗憾，经过这件事以后接受到的教训就是自己再也不能这样颓废了，家里人都 fucked up 了，以后真的只能靠自己。 这一年还是有很多我做过有趣的事，我见过有意思的人想说一下的，也有很多感想要说。但是，一说就要长篇大论了。一想，还是这样陈述一下比较好，客观一些，少带一些个人感情，自己回顾起来也好一点。 2015结束了。2016，我22岁，还是需要另外一个新的开始。","categories":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}],"tags":[],"keywords":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}]},{"title":"为什么又玩新博客","slug":"2015-09-27-morty","date":"2015-09-27T03:49:25.000Z","updated":"2015-10-09T06:32:43.000Z","comments":true,"path":"2015/09/27/2015-09-27-morty/","link":"","permalink":"https://ftandy.com/2015/09/27/2015-09-27-morty/","excerpt":"新博客，从 wordpress 到 octopress 最终到 hexo。 这也见证了自己的学习过程，从最开始最简易地在 godaddy 上搞个博客应用，到后面学 Ruby 接触到 Octopress，到现在接触前端的 Javascript，然后最后换个 hexo。 说一下最近看的神剧 Rick and Morty 吧。","text":"新博客，从 wordpress 到 octopress 最终到 hexo。 这也见证了自己的学习过程，从最开始最简易地在 godaddy 上搞个博客应用，到后面学 Ruby 接触到 Octopress，到现在接触前端的 Javascript，然后最后换个 hexo。 说一下最近看的神剧 Rick and Morty 吧。 Wubba lubba dub dub！不得不说，本剧中绝大多数科学梗都是没有科学依据，存是作者 yy 出来的。最主要的梗是平行时空梗。但是几乎每集都有一个大梗，然后在一个大梗的前提下发生各种小梗。然后各种大梗小梗还可以在每集当中前呼后应，总是能让观众找到彩蛋，或者引起观众的脑洞大开，爽到观众。这里列出来每集的大梗： 第一季 e01：药物提高智商梗。 e02：盗梦空间梗和人猿猩球梗。 e03：探索人体梗。 e04：虚拟现实梗。 e05：魔幻冒险小人巨人梗和自创的 Mr.MeeSeek 梗。 e06：基因变异梗和平行宇宙梗。 e07：男女平等梗。 e08：平行宇宙电视梗。 e09：诅咒魔法和高科技对抗梗。 e10：超级牛逼的在平行宇宙梗下的黑化 morty 梗。 e11：泰坦尼克号梗和时间停止梗。 第二季 e01：时间停止梗和时间断裂梗。 e02：虫洞梗。 e03：集体主义梗和爱情梗。 e04：超级牛逼的意识记忆潜入梗。 e05：好声音梗和宗教主义是傻逼梗。 e06：平行时空梗，迷你宇宙梗和人工智能梗。 e07：魔幻吸血鬼梗，婚姻是 shit 梗，意识肉体不能一致梗和我想你脑中我的肯定很牛逼梗（Jerry智商上限）。 e08：大义凛然切 jj 梗和 s01 e08 的平行宇宙电视梗。 不过有趣的就是，如此无节操的动画剧，在作者各种 yy 下，结合各种梗，让观众在20分钟内看得很爽啊（当然还要非常感谢电波字幕组）。有些梗看不懂，或者意犹未尽还可以去找资料和视频深挖各种知识，非常有趣。 这一年的一个美国动漫展上，作者还说 op 出现的每一幕都会有出现在后面的剧情中。 剧中的配乐也非常到位。几乎每集都有一首原创曲或者非常符合剧情的歌，有的真的非常 touching。网易云音乐上已经有很多 rick and morty 的歌单，看完之后再听又会不自觉地联想起剧情，超爽。 周边： 还有人在 iOS 上做出了爸爸 Jerry 经常玩的一款无脑游戏，Jerry’s Game，想玩的可以下来玩玩，就是一直点起球，超级无脑。。。很适合爸爸这种智商的人233333 第一集被删减没有上的剧情：Rick and Morty Season 1 第一季删减片段 1080p_综合 第一季的各种人名口号编成了一首歌：“Wubba Lubba Dub Dub” - Rick and Morty Season 1 Remix 第一季幕后制作记录片，感觉记者超级脑残，这采访。。Rick and Morty 第一季幕后制作纪录片 Season 1 Behind the Scenes 1080p_综合 但是这个剧还是适合成年人看，毕竟来自Adult Swim（已经被墙了）。 附上 rick 的口头禅的解释： “Wubba lubba dub dub” means “I am in great pain, please help me”. “Gubba nub nub doo rah kah” means “Whatever lets you sleep at night”. Wubba lubba dub dub！","categories":[{"name":"rick and morty","slug":"rick-and-morty","permalink":"https://ftandy.com/categories/rick-and-morty/"}],"tags":[],"keywords":[{"name":"rick and morty","slug":"rick-and-morty","permalink":"https://ftandy.com/categories/rick-and-morty/"}]},{"title":"brainfuck language","slug":"2015-09-26-brainfuck-language","date":"2015-09-26T04:50:38.000Z","updated":"2016-04-27T08:40:38.000Z","comments":true,"path":"2015/09/26/2015-09-26-brainfuck-language/","link":"","permalink":"https://ftandy.com/2015/09/26/2015-09-26-brainfuck-language/","excerpt":"","text":"","categories":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}],"tags":[],"keywords":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}]},{"title":"解谜类游戏","slug":"2015-09-12-","date":"2015-09-12T06:28:02.000Z","updated":"2015-10-04T10:47:26.000Z","comments":true,"path":"2015/09/12/2015-09-12-/","link":"","permalink":"https://ftandy.com/2015/09/12/2015-09-12-/","excerpt":"解谜类游戏确实有点爽。","text":"解谜类游戏确实有点爽。 知乎上的问题有哪些耐玩的独立游戏介绍了很多独立游戏。 其中的 Machinarium，Fez，Braid 简直是艺术。 类似于 Machinarium 的 The Tiny Bang Story 也不错，Gomo 也是非常类似的一个作品，而 Stick it to the man 就有点蛋疼了。 还有加入画面旋转的 Jourery of a Roach，玩得有点蛋疼。 其中未玩的有 the Cave， 特然觉得这种解谜类，剧情类的2D游戏非常上瘾。 这类游戏并不像 dota 或者魔兽那样，让你打打杀杀，而更像是跟作者思想的一种交流，每一个细节都能通过操作感觉到。","categories":[{"name":"game","slug":"game","permalink":"https://ftandy.com/categories/game/"}],"tags":[],"keywords":[{"name":"game","slug":"game","permalink":"https://ftandy.com/categories/game/"}]},{"title":"Vue 组件化开发实践","slug":"2015-09-05-vue","date":"2015-09-05T02:12:29.000Z","updated":"2017-02-13T15:13:49.000Z","comments":true,"path":"2015/09/05/2015-09-05-vue/","link":"","permalink":"https://ftandy.com/2015/09/05/2015-09-05-vue/","excerpt":"前言：这是一篇，在开发掘金的过程中，思考和总结出来，如何使用 Vue.js 和周边工具集合成一套完整舒适的组件化开发流程的文章。 之前有关如何使用 Webpack 和 vue-loader 开发 Vue 应用的文章有： 勾股大叔的 Vue + webpack 项目实践 尤大大在 CSDN 上发表的 Vue.js：轻量高效的前端组件化方案 djyde 的 Vue.js 和 Webpack 百度前端小组的 mvvm学习&amp;vue实践小结","text":"前言：这是一篇，在开发掘金的过程中，思考和总结出来，如何使用 Vue.js 和周边工具集合成一套完整舒适的组件化开发流程的文章。 之前有关如何使用 Webpack 和 vue-loader 开发 Vue 应用的文章有： 勾股大叔的 Vue + webpack 项目实践 尤大大在 CSDN 上发表的 Vue.js：轻量高效的前端组件化方案 djyde 的 Vue.js 和 Webpack 百度前端小组的 mvvm学习&amp;vue实践小结 PS：以下的任何内容都是基于 0.12 以上版本，由于 Vue 作者尤大大正在不断地加入新特性和推出新版本，1.0正式版本即将推出，不保证下文的任何内容会因新版本的内容而覆盖掉。假如本文有任何令你不爽的地方，请拍砖。 组件化模块化开发在 Vue 当中，组件被当作是一等公民，所以设计和完成一个 Web App 之前，最好先构思好如何构建各个组件，哪些组建需要被复用到，哪些页面是要切换的。在组件化和模块化的原则上，Vue 提供了一些现有流行的预编译工具的扩展， 管理 vue 可预编译文件。分别是 Webpack 派的 vue-loader 和 Gulp 派的 vueify。 Vue 希望每个单页应用都可以通过组建系统简化为各个 component。 使用 Webpack 和 vue-loader 开发的例子在 vue 后缀文件当中，定义了三个 tag，template，script，style。 12345678910111213&lt;template lang=\"jade\"&gt;&lt;/template&gt;&lt;script lang=\"babel\"&gt;export default &#123;&#125;&lt;/script&gt;&lt;style lang=\"sass\"&gt;&lt;/style&gt; 从开发的角度看，维护和开发这样的一个 vue 文件，既可以作为一个主页面引用其他的 vue 组建或者切换页，又可以作为一个 component 被其他 vue 文件引用，所有需要的 html，css，javascript 代码都在里面，结合 MVVM 的概念，使用起来非常清爽和简单。 三个 tag 中，各自可以声明自己的预编译语言，安装 Webpack 和自己所需要的 loader 之后，在 webpack.config.js 文件下配置好 loader 和文件出入口就可以了。Webpack 会将所有内容和资源预编译并打包成一个 js 文件。Webpack 的详细使用请看官网。 Webpack 的前端哲学和观点就是将一切资源（HTML，CSS，Javascirpt，图片）用 import 和 require 模块化引入，并对资源进行所需要的预处理，最终打包一个 js 文件被单页应用引入。Webpack 中有大量的特性和插件可以用来构建大型单页应用，坑略深。下面使用几个简单的 loader 来展示如何使用 Webpack 和 vue-loader 来管理一个初期的单页应用。 npm install --save-dev 安装 babel-loader，jade-loader，sass-loader，vue-loader 即可： 安装好依赖就可以构思如何设置目录了。由于一切资源都被编译成一个 js 文件，所以 public 目录下只需要保存 build 目录即可。 123456789101112131415161718192021222324nodemodule // 各种 npm 库 xxx xxxpublic build index.js // Webpack 预编译之后的文件，最终被 HTML 引入 index.html // 引入 build 目录中的 index.jsvue assets // scss 和图片资源 scss uuu.scss images ooo.png helper xxx.js // 一些 helper index components zzz.vue // 各种组件 views xxx.vue // xxx页 yyy.vue // yyy页 main.js // Webpack 预编译入口 app.vue // 被 main.js 引用的主页文件webpack.config.js // Webpack 配置文件 在 webpack.config.js 中的配置：123456789101112131415161718192021222324252627module.exports = &#123; entry: &#123; 'index': './vue/index/main.js', &#125;, output: &#123; path: './public/bulid', filename: '[filename].js' // 可以多点切入 &#125;, module: &#123; loaders: [ &#123; test: /\\.vue$/, exclude: /node_modules/, loader: vue.withLoaders(&#123; js: 'babel?optional[]=runtime' &#125;) &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass &#125;, &#123; test: /\\.css$/, loader: \"style!css\" &#125;, &#123; test: /\\.js$/, loader: 'babel-loader' &#125; ] &#125;, resolve: &#123; // 解决 npm 的依赖问题 modulesDirectories: ['node_modules'], extensions: ['', '.js', '.json'] &#125;,&#125; 有关 Webpack 的详细使用，可移步官网。 PS：调试的时候在 Chrome 中安装 vue-devtools 实时查看 Vue 实例中的绑定数据。 父子模版之间通讯组件化开发第二个问题是，如何最佳地在父子模版和各个页面之间通讯？ 考虑到子模版的可复用性，子模版最好将需要从父模版中继承的数据和自己独立的数据都区分定义好。 在 Vue 中，父子模版之间绑定了数据和方法。而在父子模版之间进行通讯，或者相互触发事件，有三种情况对应发生： 子模版数据变化，触发父模版事件。 父模版数据变化，触发子模版事件。 父模版其他子模版数据变化，触发其他子模版事件。 而在 Vue 中，提供了两种方式来使父子模版相互触发事件： 通过 watch 某个绑定双向变量触发事件。 使用事件模型事件，$dispatch，$broadcast，$on，上下 trigger 和监听事件。 对于这三种情况，Vue 提供了两个方法在父子，子父，子父子之间通讯和事件触发，已经可以应对相对复杂的情况。 PS:通过 watch 来观察双向绑定的变量然后触发某个父子方法，使父子模版之间的耦合度加强，在不得已的情况下最好不要用。只用在自身组件的变量触发事件的情况下是非常不错的。 SPA的路由切换在构建一个 SPA 页面的时候，通常需要用到一个 Router 库 。官方的 vue-router 刚刚推出，使用起来更加复杂。而使用 director，跟 components 属性进行结合，就可以做到简单并且完美的切换页面功能。 配合 Vue 提供的 component keep alive 特性，可以在切换的过程中提供缓存，真是太爽不过。需要注意的是，0.12 版本中，将 component 的 replace 属性默认设为 true，假如你没有根节点提供给子模版，子模版会自动消失。 周边工具Vue 是个非常年轻的 View 层框架，仍然有很多地方需要开发和改进，周边的工具和扩展也很少。在这里附上 vue 周边工具的地址： vue-loader：与 Webpack 结合进行组件化开发 vueify：与 Gulp 结合进行组件化开发 vue-router：路由 vue-validator：表单验证库 vue-resource：网络请求库 vue-component-complier：与其他预编译器结合 vue-touch：事件模拟 meteor-vue：meteor 与 vue 结合开发 vue-syntax-hightlight：sublime text 的 vue 文件的高亮插件 vue-typeahead：搜索输入提前查询补全 vue-i18n：i18n vue-devtools：配合 chrome 的开发插件，调试时可用","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}],"tags":[],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}]},{"title":"Tasks, microtasks, queues and schedules(译)","slug":"2015-08-23-tasks-microtasks-queues-and-schedules","date":"2015-08-23T02:51:23.000Z","updated":"2016-09-02T05:42:21.000Z","comments":true,"path":"2015/08/23/2015-08-23-tasks-microtasks-queues-and-schedules/","link":"","permalink":"https://ftandy.com/2015/08/23/2015-08-23-tasks-microtasks-queues-and-schedules/","excerpt":"原文，由 FTAndy 翻译，Ivan Yan 校正，“署名-非商用-相同方式共享”。译文反馈。","text":"原文，由 FTAndy 翻译，Ivan Yan 校正，“署名-非商用-相同方式共享”。译文反馈。 Tasks, microtasks, queues and schedulesPosted 17 August 2015 - hold onto your butts for this one, it’s spec-heavy 当我告诉我的同事 Matt Gaunt 我想写一篇文章，介绍 mircrotask 队列和浏览器事件循环。他说：“我老实跟你说，我不会看的。” 嗯，我无论如何都要写，那么我们坐下来开始享受它，ok？ 如果你更喜欢视频，Philip Roberts 在 JSConf 上就事件循环有一个很棒的演讲——没有讲 microtasks，不过很好的介绍了其它概念。好，继续！ 有下面的Javascript代码： 12345678910111213console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); log会怎么输出呢？ 试一下Clear log Run test 正确的答案是：script start, script end, promise1, promise2, setTimeout，但是各浏览器不一致。 Microsoft Edge, Firefox 40, iOS Safari 及桌面 Safari 8.0.8 在 promise1 和 promise2 之前打印 setTimeout ——尽管这似乎是竞争条件导致的。很奇怪的是，Firefox 39 和 Safari 8.0.7 是对的。 为什么会这样要想弄明白为什么，你需要知道事件循环如何处理 tasks 和 microtasks。第一次接触需要花些功夫才能弄明白。深呼吸…… 每个线程都有自己的事件循环，所以每个 web worker 有自己的事件循环（event loop），所以它能独立地运行。而所有同源的 window 共享一个事件循环，因为它们能同步的通讯。事件循环持续运行，执行 tasks 列队。一个事件循环有多个 task 来源，并且保证在 task 来源内的执行顺序（IndexedDB 等规范定义了自己的 task 来源），在每次循环中浏览器要选择从哪个来源中选取 task，这使得浏览器能优先执行敏感 task，例如用户输入。Ok ok, 留下来陪我坐会儿…… Tasks 被列入队列，于是浏览器能从它的内部转移到 Javascript/DOM 领地，并且确使这些 tasks 按序执行。在 tasks 之间，浏览器可以更新渲染。来自鼠标点击的事件回调需要安排一个 task，解析 HTML 和 setTimeout 同样需要。 setTimeout 延迟给定的时间，然后为它的回调安排一个新的 task。这就是为什么 setTimeout 在 script end 之后打印，script end 在第一个 task 内，setTimeout 在另一个 task 内。好了，我们快讲完了，剩下一点我需要你们坚持下…… Mircotasks 通常用于安排一些事，它们应该在正在执行的代码之后立即发生，例如响应操作，或者让操作异步执行，以免付出一个全新 task 的代价。mircotask 队列在回调之后处理，只要没有其它执行当中的（mid-execution）代码；或者在每个 task 的末尾处理。在处理 microtasks 队列期间，新添加的 microtasks 添加到队列的末尾并且也被执行。 microtasks 包括 mutation observer 回调。上面的例子中的 promise 的回调也是。 promise 一旦解决（settled），或者已解决，它便为它的回调安排一个 microtask。这确使 promise 回调是异步的，即便 promise 已经解决。因此一个已解决的 promise 调用 .then(yey, nay) 将立即把一个 microtask 加入队列。这就是为什么 promise1 和 promise2 在 script end 之后打印，因为正在运行的代码必须在处理 microtasks 之前完成。promise1 和 promise2 在 setTimeout 之前打印，因为 microtasks 总是在下一个 task 之前执行。 好，一步一步的运行： console.log(‘script start’);setTimeout(function() { console.log(‘setTimeout’);}, 0);Promise.resolve().then(function() { console.log(‘promise1’);}).then(function() { console.log(‘promise2’);});console.log(‘script end’);TasksRun scriptsetTimeout callbackMicrotasksPromise thenPromise thenJS stackLogscript startscript endpromise1promise2setTimeout 是的，我做了一个 step-by-step 动画图解。你周六是怎么过的？和朋友们出去晒太阳？我没有。嗯，如果不明白我的 UI 设计，点击上面的箭头。 其它浏览器有什么不同？一些浏览器的打印结果：script start, script end, setTimeout, promise1, promise2。在 setTimeout 之后运行 promise 的回调，就好像将 promise 的回调当作一个新的 task 而不是 microtask。 这多少情有可原，因为 promise 来自 ECMAScript 规范而不是 HTML 规范。ECAMScript 有一个概念 job，和 microtask 相似，但是两者的关系在邮件列表讨论中没有明确。不过，一般共识是 promise 应该是 microtask 队列的一部分，并且有充足的理由。 将 promise 当作 task 会导致性能问题，因为回调可能不必要地被与 task 相关的事（比如渲染）延迟。与其它 task 来源交互时它也导致不确定性，也会打断与其它 API 的交互，不过后面再细说。 我提交了一条 Edge 反馈，它错误地将 promises 当作 task。WebKit nightly 做对了，所以我认为 Safari 最终会修复，而 Firefox 43 似乎已经修复。 有趣的是 Safari 和 Firefox 发生了退化，而之前的版本是对的。我在想这是否只是巧合。 怎么知道是 task 还是 microtask？测试是一种办法，查看相对于 promise 和 setTimeout 如何打印，尽管这取决于实现是否正确。 一种方法是查看规范。例如，setTimeout 的第十四步将一个 task 加入队列，mutation record 的第五步将 microtask 加入队列。 如上所述，ECMAScript 将 microtask 称为 job。PerformPromiseThen 的第八步 调用 EnqueueJob 将一个 microtask 加入队列。 现在，让我们看一个更复杂的例子。（一个有心的学徒 ：“但是他们还没有准备好”。别管他，你已经准备好了，让我们开始……） 等级 1 BOSS战在我写这篇博文之前，我就已经把这个搞错了。这是一段 html 代码： 123&lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 有如下的 Javascript 代码，假如我点击 div.inner 会发生什么 log 呢？ 123456789101112131415161718192021222324252627282930// Let's get hold of those elementsvar outer = document.querySelector('.outer');var inner = document.querySelector('.inner');// Let's listen for attribute changes on the// outer elementnew MutationObserver(function() &#123; console.log('mutate');&#125;).observe(outer, &#123; attributes: true&#125;);// Here's a click listener…function onClick() &#123; console.log('click'); setTimeout(function() &#123; console.log('timeout'); &#125;, 0); Promise.resolve().then(function() &#123; console.log('promise'); &#125;); outer.setAttribute('data-random', Math.random());&#125;// …which we'll attach to both elementsinner.addEventListener('click', onClick);outer.addEventListener('click', onClick); 继续，在看答案之前想清楚。 试一下吧点击下面内部的矩形出发一个 click 事件： Clear log 你的估计和结果是否一样？假如是，你可能是正确的。但不幸的是浏览器不会同意这一点： click promise mutate click promise mutate timeout timeout click mutate click mutate timeout promise promise timeout click mutate click mutate promise promise timeout timeout click click mutate timeout promise timeout promise 谁是对的？触发 click 事件是一个 task，Mutation observer 和 promise 回调作为 microtask 加入列队，setTimeout 回调作为 task 加入列队。因此运行过程如下： // Let’s get hold of those elementsvar outer = document.querySelector(‘.outer’);var inner = document.querySelector(‘.inner’);// Let’s listen for attribute changes on the// outer elementnew MutationObserver(function() {console.log(‘mutate’);}).observe(outer, {attributes: true});// Here’s a click listener…function onClick() {console.log(‘click’);setTimeout(function() {console.log(‘timeout’);}, 0);Promise.resolve().then(function() {console.log(‘promise’);});outer.setAttribute(‘data-random’, Math.random());}// …which we’ll attach to both elementsinner.addEventListener(‘click’, onClick);outer.addEventListener(‘click’, onClick);TasksDispatch clicksetTimeout callbacksetTimeout callbackMicrotasksPromise thenMutation observersPromise thenMutation observersJS stackLogclickpromisemutateclickpromisemutatetimeouttimeout所以 Chrome 是对的。对我来说新发现是，microtasks 在回调之后运行（只要没有其它的 Javascript 在运行，我原以为它只能在 task 的末尾运行。这个规则来自 HTML 规范，调用一个回调：If the stack of script settings objects is now empty，perform a microtask checkpoint。 —— HTML: 回调之后的清理第三步 一个 microtask checkpoint 逐个检查 microtask 队列，除非我们已经在处理一个 microtask 队列。类似地，ECMAScript 规范这么说 jobs：Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty… —— ECMAScript: Jobs and Job Queues 尽管在 HTML 中”can be”变成了”must be”。其它浏览器哪里错了？对于 mutation 回调，Firefox 和 Safari 正确地在单击回调之间清空 microtask 队列，但是 promises 列队似乎不一样。这多少情有可原，因为 jobs 和 microtasks 的关系不清楚，但是我仍然期望在事件回调之间处理。Firefox bug。Safari bug。对于 Edge，我们已经看到它错误的将 promises 当作 task，它也没有在单击回调之间清空 microtask 队列，而是在所有单击回调执行完之后清空，于是总共只有一个 mutate 在两个 click 之后打印。Edge bug。等级 1 BOSS愤怒的老大哥使用上面相同的的例子，假如我们执行这个会发生什么呢：1inner.click();这会在事件触发之前执行，在顶级作用域的代码，而不是交互事件中。试一下Clear log Run test下面是各浏览器的结果： click click promise mutate promise timeout timeout click click mutate timeout promise promise timeout click click mutate promise promise timeout timeout click click mutate timeout promise timeout promise 我发誓我在 Chrome 中始终得到不同的结果，我更新了这个表许多次才意识到我测试的是 Canary。假如你在 Chrome 中得到了不同的结果，请在评论中告诉我是哪个版本。为什么不一样？下面是所发生的：// Let’s get hold of those elementsvar outer = document.querySelector(‘.outer’);var inner = document.querySelector(‘.inner’);// Let’s listen for attribute changes on the// outer elementnew MutationObserver(function() { console.log(‘mutate’);}).observe(outer, { attributes: true});// Here’s a click listener…function onClick() { console.log(‘click’); setTimeout(function() { console.log(‘timeout’); }, 0); Promise.resolve().then(function() { console.log(‘promise’); }); outer.setAttribute(‘data-random’, Math.random());}// …which we’ll attach to both elementsinner.addEventListener(‘click’, onClick);outer.addEventListener(‘click’, onClick);inner.click(); TasksRun scriptsetTimeout callbacksetTimeout callbackMicrotasksPromise thenMutation observersPromise thenJS stackLogclickclickpromisemutatepromisetimeouttimeout 正确的顺序是：click, click, promise, mutate, promise, timeout, timeout，似乎 Chrome 是对的。 在每个事件回调调用之后： If the stack of script settings objects is now empty，perform a microtask checkpoint. — HTML: 回调之后的清理第三步 之前，这意味着 microtasks 在事件回调之间运行，但是 .click() 让事件同步触发，所以调用 .click() 的代码仍然在事件回调之间的栈内。上面的规则确保了 microtasks 不会中断执行当中的代码。这意味着 microtasks 队列在事件回调之间不处理，而是在它们之后处理。 这重要吗？重要，它会在偏角处咬你（疼）。我就遇到了这个问题，在我尝试用 promises 而不是用怪异的 IDBRequest 对象为 IndexedDB 创建一个简单的包装库 时。它让 IDB 用起来很有趣。 当 IDB 触发成功事件时，相关的 transaction 对象在事件之后转为非激活状态（第四步）。如果我创建的 promise 在这个事件发生时被履行（resolved)，回调应当在第四步之前执行，这时这个对象仍然是激活状态。但是在 Chrome 之外的浏览器中不是这样，导致这个库有些无用。 实际上你可以在 Firefox 中解决这个问题，因为 promise polyfills 如 es6-promise 使用 mutation observers 执行回调，它正确地使用了 microtasks。而它在 Safari 下似乎存在竞态条件，不过这可能是因为他们糟糕的 IDB 实现。不幸的是 IE/Edge 不一致，因为 mutation 事件不在回调之后处理。 希望不久我们能看到一些互通性。 你做到了！总结： tasks 按序执行，浏览器会在 tasks 之间执行渲染。 microtasks 按序执行，在下面情况时执行： 在每个回调之后，只要没有其它代码正在运行。 在每个 task 的末尾。 希望你现在明白了事件循环，或者至少得到一个借口出去走一走躺一躺。 呃，还有人在吗？Hello？Hello？ 感谢 Anne van Kesteren, Domenic Denicola, Brian Kardell 和 Matt Gaunt 校对和修正。是的，Matt 最后还是看了此文，我不必把他整成发条橙了。 译注：setImmediate.js 也提到了 tasks 与 microtasks 的区别，供参考。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}],"tags":[],"keywords":[{"name":"javascript","slug":"javascript","permalink":"https://ftandy.com/categories/javascript/"}]},{"title":"Docker 初探","slug":"2015-07-05-docker","date":"2015-07-05T06:57:07.000Z","updated":"2015-10-04T10:52:25.000Z","comments":true,"path":"2015/07/05/2015-07-05-docker/","link":"","permalink":"https://ftandy.com/2015/07/05/2015-07-05-docker/","excerpt":"Docker 与 VagrantDocker 和 Vagrant 是近期两个应用场景最像的计算机虚拟化技术了吧。Stackoverflow 上有一个问题是问在什么场景下应该用 Vagrant，什么场景下应该使用 Docker，而 Vagrant 和 Docker 的作者也都出来争论了，有兴趣的可以去看看大牛是怎么撕逼的。 Docker 将 Git 版本管理的概念与 Linux 上 Container 的概念融合在一起，而 Vagrant 则是将 Git 版本管理的概念与虚拟机的概念融合在一起。","text":"Docker 与 VagrantDocker 和 Vagrant 是近期两个应用场景最像的计算机虚拟化技术了吧。Stackoverflow 上有一个问题是问在什么场景下应该用 Vagrant，什么场景下应该使用 Docker，而 Vagrant 和 Docker 的作者也都出来争论了，有兴趣的可以去看看大牛是怎么撕逼的。 Docker 将 Git 版本管理的概念与 Linux 上 Container 的概念融合在一起，而 Vagrant 则是将 Git 版本管理的概念与虚拟机的概念融合在一起。 下面是我自己画的 Vagrant 架构，其实也是在虚拟机上抽象出一层类似于 Git 的管理工具。 OS X 下的 Docker由于 Container 是 Linux 特有的概念，所以想要在 OS X 下玩 Docker，还是需要依赖虚拟机。官网上推荐的配套 Docker 虚拟机叫 boot2docker。可以到官网上按照教程安装。你也可以使用 Vagrant，然后在 Vagrant 中的 Linux 虚拟机中配置安装 Docker，在虚拟机中玩 Docker。 用户在命令行或者 GUI 下与 Docker 交互主要通过与 Docker daemon 对话，Docker daemon 再管理每个 Container。所以在 OS X 上会出现这样的架构： OS X 下的 Docker 的使用下面是一些在 Docker 在 OS X 中使用的命令行。 由于依赖于 boot2docker，所以一开始必须要先初始化 boot2docker。 12345$ boot2docker init$ boot2docker start$ boot2docker shellinit 现在 virtual box 中的 docker 也是安装和初始化好了，直接用即可。 123$ docker run hello-world //开启一个Container，输出hello-world，然后结束Container-$ docker run -d -P —name web nginx //-d参数一直运行，-P参数将Container的端口映射到虚拟机的端口上 boot2docker和Docker常用状态管理命令。 1234567$ boot2docker status //查看虚拟机状态$ docker ps //查看虚拟机中所有的Container$ docker port web/xxx //查看正在运行的Container的端口号$ boot2docker ip //查看虚拟机在本机网络中的IP地址 Docker 可以开启一个 Container，里面再运行一个虚拟机。 12345$ docker pull ubuntu //从官方仓库中拉ubantu的镜像$ docker run -t -i ubuntu /bin/bash //运行ubuntu虚拟机并使用bash，-t表示开启终端，-i表示交互显示$ docker images //查看本地所有镜像 官方提供了一个类似于 Github 的平台叫 Docker Hub，可以存储自己的镜像，或者与别人分享镜像。 1234567891011$ docker run -t -i training/sinatra /bin/bash //进入从镜像库中拉下来的镜像# gem install json //修改镜像$ docer commit -m “install json gem” container_id new_contailer_name //确认修改镜像$ docker images //查看新的修改过的镜像$ docker tag 91c95931e552 ftandy/hello_sss //为自己的镜像修改别名$ docker push ftandy/hello_sss //push到自己的账号仓库上 分享的话也可以通过本地导出导出镜像文件分享。 123$ docker save -o hello-world.tar hello-world$ docker load &lt; hello-world.tar 另外想要进阶的话，推荐这本电子书，和陈皓的博客。里面包含了Docker的方方面面。 参考资料 http://dockerpool.com/static/books/docker_practice/introduction/README.html https://www.docker.com/","categories":[{"name":"vagrant_docker","slug":"vagrant-docker","permalink":"https://ftandy.com/categories/vagrant-docker/"}],"tags":[],"keywords":[{"name":"vagrant_docker","slug":"vagrant-docker","permalink":"https://ftandy.com/categories/vagrant-docker/"}]},{"title":"Compiler 暂时不开课，但是不要紧","slug":"2015-06-17-complier","date":"2015-06-17T04:12:41.000Z","updated":"2015-10-04T10:57:12.000Z","comments":true,"path":"2015/06/17/2015-06-17-complier/","link":"","permalink":"https://ftandy.com/2015/06/17/2015-06-17-complier/","excerpt":"stanford 的 compiler 暂时还没有开课，但是我已经在看作业说明了，发现第一个作业的说明怎么这么难懂，这要尼玛说什么啊。所以就把作业说明先翻译出来，自己做个笔记，以后开课的时候可以看。","text":"stanford 的 compiler 暂时还没有开课，但是我已经在看作业说明了，发现第一个作业的说明怎么这么难懂，这要尼玛说什么啊。所以就把作业说明先翻译出来，自己做个笔记，以后开课的时候可以看。 作业说明pdf地址。 下面是用flex做词法分析器要求的翻译，其他的资源如cool手册和flex的手册课程上都有给链接。 3.文件和目录要开始的话，在你想要做作业的地方创建一个新的目录，执行下面的指令在那个新目录。1make -f /usr/class/cs143/assignments/PA2/Makefile 这个命令将产生一堆文件，下面对三个文件进行说明： cool.flex 这个文件包含了一个Cool的词法分析器骨架。里面有注释会指导你该怎么写代码，但是这些注释不是一个完整的说明。这个作业的一部分目的是为了让你清楚你有一个正确的词法分析器。除了这个章节的指引，你也可以自己加一些特别的东西进去。你可以在这个骨架上构造一个词法扫描器，但不是必要的。你应该去阅读好flex的手册去弄明白这段描述究竟让你做什么。其他任何的你想要在这个骨架上加的常规的东西都应该直接加到这个骨架上的合适的位置。（去研究那些注释吧，少年。） test.cl 这个文件包含了一些正常的输入可以被词法分析器扫描。它不会包含了Cool语言的所有语法特性，但是不影响它是一个有趣的测试文件。你也可以自由地去修改这个文件被你的词法分析器扫描。 4 词法扫描结果在这个课程中，你需要写Flex的规则去匹配正确的正则表达式，认证Cool正确的taken，产生正确的动作，纪录词法的值，或者抛出错误当错误条件触发时。有关正确token资料在Cool手册的第十章第一节上。在你做这个作业之前，确保你认真阅读了Cool手册的第十章第一节，然后学习不同的token是怎么在cool-parse.h文件上定义的（这个文件在cool编译器中有）。你应该实现Flex的规则为每个在cool-parse.h上定义的正确的token，去匹配对应的正则表达式，为每个token执行正确的动作。例如：假如你匹配了一个BOOL_CONST的token，你的词法分析器必须记录这个bool的值是真还是假；相似的，假如你匹配了一个TYPEID的token，你应该记录这个type的的名字。注意，不是每个token都需要记录额外的信息；例如，只有返回的token类型符合某些token类型才需要记录额外信息，例如：keywords。 你的词法扫描器健壮性一定要强，应该可以在任何可以想象到的输入都正常工作。例如，你必须要处理错误，当关键词EOF出现在字符串或者注释中间的时候，还有就是字符串过长的情况也要考虑。这都是一些你应该处理的常见错误，其余的部分自己看手册啦。 假如一个错误出现，你必须优雅地引起错误并显示。核心异常或者不可捕捉的异常是不可以接受的。 4.1 错误处理所有错误信息都应该传递语法分析器。词法分析器不应该输出任何东西。错误应该通过返回特殊的错误信息ERROR与语法分析器进行交流（注意，你应该忽视名为error的token，这个是在作业3中的语法分析器中用的）。还有几个需要注意的地方需要词法分析器错误抛出： 当一个不合法的字符（一个不匹配任何token的字符）出现的时候，那个包含这个字符的字符串应该返回为一个错误的字符串。继续为下一个token进行解释。 假如一个字符串含有一个unescaped的新行，报告这个错误为‘‘Unterminated string constant’’，然后继续解析下一行，我们假设程序员忘记了写引号的下一半。 假如一个字符串太长，报告这个错误为‘‘String constant too long’’为这个字符串类型为ERROR。假如这个字符串含有不合法的字符（例如：null字符），报告这个错误为 ‘‘String contains null character’’。在任何错误情况下，词法解析器都应该在这个字符串的结尾为下一个字符解析。这个结尾应该是下面这几种情况： 这个错误出现之后，假如一个unescaped的新行出现在这个下一行的开始。 在”之后。 假如一个注释里面有EOF关键词，报告这个错误‘‘EOF in comment’’。不要尝试去解析注释里面的内容。类似的，假如一个字符串里面有EOF关键词，报告这个错误‘‘EOF in string constant’’。 假如有”)” 在一个注释之外，报告这个错误‘‘Unmatched )’’，而不要分析它为 * 和 )。 回想起这次课，这阶段的编译器只是捕捉非常有限的错误。不要尝试去检查不是在词法解析器的错误。例如，不应该检查一个在用变量之前，变量是否声明了。确认你充分了解什么错误处理词法分析器应该做，在你没有了解之前不要开始。 4.2 字符串表程序会对一个token分析多次。例如，一个定义标示一般都会在程序中用到很多次。为了节省空间和时间，一个正常编译器的实现方法是保存词法在一个字符串表上。我们提供一个字符串表的C++接口。 有一个问题，就是怎么为基础的类（Object, Int, Bool, String）,SELF_TYPE和self，去处理特殊的定义标示。在语法分析器部分之前，这个问题不会真正出现。词法分析器应该处理这些特殊标示符像其他定义标示一样。 4.3 字符串词法分析器应该对一个字符串的中逃离的字符进行转义，变成一个正确的字符串。例如，假如这个字符串为”ab\\ncd”，词法分析器应该返回 STR_CONST，值为ab\\ncd，其中\\n为单独的字符。根据Cool手册第15页的描述，你应该为包含了null字符的字符串返回一个错误信息。像\\0这样的转义字符应该转化为0。 4.4 其他需要注意的地方词法分析器因该保留变量curr_lineno，指出现在分析的词是在源文件中的第几行。这个功能会帮助语法分析器打印出有用的错误信息。 你应该忽视token LET_STMT。这个会在作业3中的使用。最后，注意假如词法分析器不完整的话，flex生成的C语言文件将不能正常运行，保证每一部分都正确。 5 特别注意 每次token解析完，都需要从输入中对下一个token进行处理。这个值的返回的函数为cool_yylex，是一个完整的代码，代表了语法的类型（例如：整型语法，分号，关键字等等）。所有token的定义代码在cool-parse.h上。第二部分，token的值或词法单位，放在了一个全局变量cool_yylval中，它的类型是YYSTYPE。 YYSTYPE类型同样被定义在cool-parse.h中。单个字符符号的token（例如：;和,）代表着对应的ASCII值。所有单个字符token都被列在了Cool手册的语法部分上。 对于类，对象，整型，字符串的标示符，语意值应该为一个符号保存在cool_yyval.symbol文件中。对于布尔型变量，语意值应该保存在cool_yylval.boolean文件中。除了错误之外，其他词法解析的token都不需要携带其他游泳的信息。 我们提供了一个字符串表的实现，细节讨论在A Tour of the Cool Support Code这个页面上。在这个时间，你只需要去了解字符串表的输入类型是Symbol。 当一个词法错误发生的时候，cool_yylex应该返回ERROR的token。语意值为该字符串代码的错误信息，应该存储cool_yylval.error_msg文件（这应该是一个原始的字符串，而不是symbol）。","categories":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}],"tags":[],"keywords":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}]},{"title":"The Truth Is","slug":"2015-06-16-the-truth-is","date":"2015-06-16T07:23:14.000Z","updated":"2015-10-04T11:00:02.000Z","comments":true,"path":"2015/06/16/2015-06-16-the-truth-is/","link":"","permalink":"https://ftandy.com/2015/06/16/2015-06-16-the-truth-is/","excerpt":"The truth is","text":"The truth is","categories":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}],"tags":[],"keywords":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}]},{"title":"Cool Language","slug":"2015-06-11-cool-language","date":"2015-06-11T06:31:03.000Z","updated":"2015-10-04T11:03:31.000Z","comments":true,"path":"2015/06/11/2015-06-11-cool-language/","link":"","permalink":"https://ftandy.com/2015/06/11/2015-06-11-cool-language/","excerpt":"斯坦福的编译课程中的需要做出来的语言，完整介绍地址。因为在这个课程中需要把这个语言完成做出来，所以熟悉好这门语言和各种细节是很有必要的。 由于 Virtual Box 的 GUI 看得不爽，找了一下发现了这个。顺着路子找发现了这个，原来可以在本地上安装好课程环境。我就用 Vagrant 了。","text":"斯坦福的编译课程中的需要做出来的语言，完整介绍地址。因为在这个课程中需要把这个语言完成做出来，所以熟悉好这门语言和各种细节是很有必要的。 由于 Virtual Box 的 GUI 看得不爽，找了一下发现了这个。顺着路子找发现了这个，原来可以在本地上安装好课程环境。我就用 Vagrant 了。 Cool语言介绍特性关键字： object-oriented static typing and type safe automatic memory management expression Cool语言基于 MIPS处理器 处理。本课程中用使用了一种 MIPS 处理器的模拟器 spim。课程上的那个 spim 是 misp 的变种，可以直接运行 cool 语言编译出来的可执行文件。 编译和执行过程就是： cool 源码—–&gt; spim 的可执行文件—–&gt; spim 翻译成机器指令—–&gt;执行 编译命令： 1coolc file1.cl 生成目标可执行文件file1.s 用 spim 虚拟机执行命令： 123456$ spim #进入模拟环境(spim) load \"file1.s\" #模拟环境操作(spim) run(spim) reinit #清内存，重新加载环境$ spim -file file.s #也可以直接执行 类源文件必须有一个定义好 main 方法的 Main 类，每个源文件可以有多个类。所有类对外可见。类名称必须大写。类不可重写。 类内部声明123456789101112131415class Cons inherits List &#123; xcar : Int; #属性 xcdr : List; #属性 isNil() : Bool &#123; false &#125;; #方法 init(hd : Int, tl : List) : Cons &#123; #构造方法 &#123; xcar &lt;- hd; xcdr &lt;- tl; self; &#125; &#125;;&#125;; 内部声明只有两种类型：属性和方法，都不可重复定义，首字母都必须小写。方法的最后一行语句为该方法返回值，用 return 可中途返回。赋值符号用-&gt;而不是= 。类构造方法为 init() 。没有析构方法，因为用的是自动垃圾回收机制 GC。 继承1class C inherits P &#123; ... &#125;; 采用单继承。C继承自P，C享有P所有属性和方法。声明类不使用继承的话，默认继承自Object。Object是最终类，Int, String, Bool, and IO是基类。 类型所有声明的类名都变成类型。所有变量和参数都需要声明类型。假如C继承自P，那么P声明的变量也可用C来代替。使用 SELF_TYPE 可以返回自身的类类型。编译运行时必须保证所有变量和返回都有类型，保证运行时不会有类型错误发生，这是静态检查，所以 Cool 是静态类型语言。 属性1&lt;id&gt; : &lt;type&gt; [ &lt;- &lt;expr&gt; ]; 后面执行语句是可选的，假如没有在声明时指定值，默认值为 void。void 没有值，可以用 isvoid 方法判断是否为 void。 方法1&lt;id&gt;(&lt;id&gt; : &lt;type&gt;,...,&lt;id&gt; : &lt;type&gt;): &lt;type&gt; &#123; &lt;expr&gt; &#125;; 参数和返回值要声明好返回类型。继承的子类可以重载方法。 表达式语句常量布尔类型常量 true, false。整型类型常量以存数字出现。字符串常量以 “xxxxx” 出现，最大为1024个字。三种常量基于类 Bool，Integer，String。 标示符包括本地变量，方法参数，self，类属性。self 不能以赋值形式出现。 赋值1&lt;id&gt; &lt;- &lt;expr&gt; 可以出现声明式赋值，也可以隐式赋值，类型为值类型。 方法调用123&lt;expr&gt;.&lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;)&lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;) #相当于self.&lt;id&gt;(&lt;expr&gt;,...,&lt;expr&gt;)&lt;expr&gt;@&lt;type&gt;.id(&lt;expr&gt;,...,&lt;expr&gt;) 条件判断判断的条件类型必须为 Bool 型。1if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt; fi 循环同样，判断的条件类型必须为Bool型。1while &lt;expr&gt; loop &lt;expr&gt; pool 块1&#123; &lt;expr&gt;; ... &lt;expr&gt;; &#125; 块后面可以不加;号，返回值为最后的语句的值。 let赋值1let &lt;id1&gt; : &lt;type1&gt; [ &lt;- &lt;expr1&gt; ], ..., &lt;idn&gt; : &lt;typen&gt; [ &lt;- &lt;exprn&gt; ] in &lt;expr&gt; case12345case &lt;expr0&gt; of&lt;id1&gt; : &lt;type1&gt; =&gt; &lt;expr1&gt;;. . .&lt;idn&gt; : &lt;typen&gt; =&gt; &lt;exprn&gt;;esac new 创建对象1new &lt;type&gt; Isvoid判断是否为 void1isvoid expr 算术符号四种基本的算术符号：+ - * /。1expr1 &lt;op&gt; expr2 左右表达式的类型必须为 Integer，Cool 中只有整形算术。比较类型&lt; &lt;= &gt;。&lt; &lt;=可以比较同类型的表达式，返回为 true 或 false。=比较地址是否相同，值相同为 false。 基本类ObjectObject 是所有继承链的最终类。123abort() : Objecttype_name() : Stringcopy() : SELF_TYPE 提供三个方法，abort() 会抛出错误，type_name() 会返回当前对象的类型名，copy() 会返回当前对象的一个副本，但是只是一个复制，不是指针，也不是引用。 IO1234out_string(x : String) : SELF_TYPEout_int(x : Int) : SELF_TYPEin_string() : Stringin_int() : Int out_string 和 out_int 对应打印出 String, Integer，返回 IO 类型。in_string, in_int对应输入 String, Integer。 Int只提供类型和值，初始化默认值为0。不能从 Int 类继承。 String123length() : Intconcat(s : String) : Stringsubstr(i : Int, l : Int) : String 初始化默认值为””。不能从 String 中继承。 Bool只提供类型和值，初始化默认值为 false。不能从 Bool 类中继承。 Main每个源文件必须有一个Main类，类中必须有一个main方法。执行程序从main方法开始。 词法结构Integers, Identifiers, and Special Notation整数为0~9的数，标识符由字母，数字，底线符号组成，类型名第一个字母为大写，对象第一个字母为字符。keyword 不能作为声明类型 String“\\x”翻译成”x”，EOF 不能包含在字符串里 1234\\b backspace\\t tab\\n newline\\f formfeed Comments两个--之间的语句，(*...*)中间。 KeyWords1class, else, false, fi, if, in, inherits, isvoid, let, loop, pool, then, while,case, esac, new, of, not, true White Space123456blank (ascii 32), \\n (newline, ascii 10),\\f (form feed, ascii 12),\\r (carriage return, ascii 13),\\t (tab, ascii 9),\\v (vertical tab, ascii 11) d","categories":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}],"tags":[],"keywords":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}]},{"title":"为什么我在看 coursera 的 complier 课程？","slug":"2015-06-09-","date":"2015-06-08T20:14:04.000Z","updated":"2015-10-04T11:03:56.000Z","comments":true,"path":"2015/06/09/2015-06-09-/","link":"","permalink":"https://ftandy.com/2015/06/09/2015-06-09-/","excerpt":"什么是程序员三大浪漫知乎上的一个提问为什么程序员的三大浪漫是编译原理，图形学，操作系统？还有提问如何去学习程序员的三大浪漫，编译原理，图形学，操作系统？","text":"什么是程序员三大浪漫知乎上的一个提问为什么程序员的三大浪漫是编译原理，图形学，操作系统？还有提问如何去学习程序员的三大浪漫，编译原理，图形学，操作系统？ vczh 的回答为什么要学习这三大浪漫 其实这个概念主要是 vczh 提出来的，其他在计算机混得比较开的人也很多人赞同。 讨论总结出的理由无非几个： 这三个东西都是计算机领域的基础，应用非常广泛，了解和深入都对以后走程序员职业的道路有很大帮助。 新的框架和语言变化太快，基础的东西都是最决定性的，了解最根本的原理可以令你看得更远。 在学习过程中需要长期集中精力，是一个长期收益性的学习，但在学习完之后不像其他技术，可以马上得以应用。像学 Rails，前端，iOS，安卓等即学即用的技术，是短期收益性的东西，学完之后可以去参加工作。 要成为大牛，必须要学！ 为什么我还要再学一次complier学校课程太水，连编译器都没有完整写过，记得不多了。也看过《龙书》，但是龙书实在太理论，各种概念，看得比较蛋疼，未果。 但是最近比较闲，想继续学习计算机比较底层东西，希望以后可以走得更远，就找了 coursera 的 complier 课程。 这门课难吗？难。学这个东西苦逼？苦逼。但值得学吗？值。 假如我继续去 dig 有关 Rails，前端，iOS 的东西，我可以过得更舒服，可以学到更多炫酷的东西。但是我在担忧，当我学完这些东西，我以后可以走得更远吗？这个答案是否定的，因为学这些东西，都是别人创造出来的工具，而自己只是去学习如何使用这个工具，不理解原理，这是一件多么蛋疼的事。因为你用工具只是搬砖工，别人设计的是科学家，你这个搬砖的不学这些永远达不到科学家的水平。 所以看得远一点，去学这三大浪漫，是一个上策。学如何使用工具，是一个下策。","categories":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}],"tags":[],"keywords":[{"name":"programming_language","slug":"programming-language","permalink":"https://ftandy.com/categories/programming-language/"}]},{"title":"Ruby core class reloadtionship","slug":"2015-06-07-ruby-core-class-reloadtionship","date":"2015-06-06T21:40:51.000Z","updated":"2015-10-04T10:31:04.000Z","comments":true,"path":"2015/06/07/2015-06-07-ruby-core-class-reloadtionship/","link":"","permalink":"https://ftandy.com/2015/06/07/2015-06-07-ruby-core-class-reloadtionship/","excerpt":"Ruby 核心类的关系Ruby 主要由标准库和核心类构成，有一些标准库会在你打开 irb 的时候自动加载，有些则是要自己手动加载，不过所有核心类都是默认配置的。","text":"Ruby 核心类的关系Ruby 主要由标准库和核心类构成，有一些标准库会在你打开 irb 的时候自动加载，有些则是要自己手动加载，不过所有核心类都是默认配置的。 上次在stackoverflow 找到这幅图之后一直想要把这幅图清晰化，这样就可以清晰知道 Ruby 核心类的骨架是怎么样的了，用的时候也可以在这个骨架上 中找到自己想要的类。 自己画图首先Ruby2.2.0核心类总共有123个类，先筛选出比较重要的类 ConditionVariable 线程同步互斥资源化 Queue 线程之间用队列通讯 SizedQueue 限制了Queue的大小，当超出Queue大小时发生阻塞 Array 基本的数组 Bignum 比Fixnum大的数的类型 BasicObject Object的父类 Object 所有对象最终都继承自Object Module 模块 Class 类 TODO","categories":[{"name":"ruby","slug":"ruby","permalink":"https://ftandy.com/categories/ruby/"}],"tags":[],"keywords":[{"name":"ruby","slug":"ruby","permalink":"https://ftandy.com/categories/ruby/"}]},{"title":"leetcode 第三题","slug":"2015-06-07-leetcode","date":"2015-06-06T19:00:32.000Z","updated":"2016-02-22T09:18:20.000Z","comments":true,"path":"2015/06/07/2015-06-07-leetcode/","link":"","permalink":"https://ftandy.com/2015/06/07/2015-06-07-leetcode/","excerpt":"Same Tree题目地址：https://leetcode.com/problems/same-tree/","text":"Same Tree题目地址：https://leetcode.com/problems/same-tree/ Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 判断两个二叉树是否相同。 利用递归即可。 ruby版： 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode# attr_accessor :val, :left, :right# def initialize(val)# @val = val# @left, @right = nil, nil# end# end# @param &#123;TreeNode&#125; p# @param &#123;TreeNode&#125; q# @return &#123;Boolean&#125;def is_same_tree(p, q) if (q.nil? &amp;&amp; p.nil?) return true elsif (q.nil? || p.nil?) || (q.val != p.val) return false elsif q.val == p.val return is_same_tree(q.left, p.left) &amp;&amp; is_same_tree(q.right, p.right) endend","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://ftandy.com/categories/leetcode/"}],"tags":[],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://ftandy.com/categories/leetcode/"}]},{"title":"leetcode 第二题","slug":"2015-05-30-maximum_depth_of_binary_tree","date":"2015-05-30T07:19:10.000Z","updated":"2016-02-22T09:18:23.000Z","comments":true,"path":"2015/05/30/2015-05-30-maximum_depth_of_binary_tree/","link":"","permalink":"https://ftandy.com/2015/05/30/2015-05-30-maximum_depth_of_binary_tree/","excerpt":"Maximum Depth of Binary Tree题目地址：https://leetcode.com/problems/maximum-depth-of-binary-tree/","text":"Maximum Depth of Binary Tree题目地址：https://leetcode.com/problems/maximum-depth-of-binary-tree/ Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.题目描述：找出二叉树中最深节点的深度 利用递归即可。 Ruby 版： 1234567891011121314# Definition for a binary tree node.# class TreeNode# attr_accessor :val, :left, :right# def initialize(val)# @val = val# @left, @right = nil, nil# end# end# @param &#123;TreeNode&#125; root# @return &#123;Integer&#125;def max_depth(root) root.nil? ? 0 : [max_depth(root.left) + 1, max_depth(root.right) + 1].maxend","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://ftandy.com/categories/leetcode/"}],"tags":[],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://ftandy.com/categories/leetcode/"}]},{"title":"leetcode 第一题","slug":"2015-05-27-single-number","date":"2015-05-27T07:55:38.000Z","updated":"2016-02-22T09:08:06.000Z","comments":true,"path":"2015/05/27/2015-05-27-single-number/","link":"","permalink":"https://ftandy.com/2015/05/27/2015-05-27-single-number/","excerpt":"开始算法很弱啊，怎么办啊，边看《算法》边做题吧。听说 leetcode 的题很适合初入职场的菜鸟，就来吧。我把 Ruby 版的 leetcode 解题过程放在了github上。","text":"开始算法很弱啊，怎么办啊，边看《算法》边做题吧。听说 leetcode 的题很适合初入职场的菜鸟，就来吧。我把 Ruby 版的 leetcode 解题过程放在了github上。 Single number题目地址：https://leetcode.com/problems/single-number/ Given an array of integers, every element appears twice except for one. Find that single one.Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?题目描述：一个数组有很多个整形数，每个数出现两次，但是只有一个数出现一次，找出那个数。 用 Ruby 标准库的index和rindex一行搞定。 123def single_number(nums) nums.each &#123;|num| return num if nums.index(num) == nums.rindex(num) &#125;end 做完之后发现很多人倾向于用xor异或运算，也是一行搞定。 ^运算： 按位运算时，同为0，异为1。 法则：a ^ b ^ c 与 a ^ c ^ b 相同。 a ^ a = 0，a ^ 0 = a 所以当所有数做异或运算时，相同的两个数最终为0，而0异或任何数为任何数，得到唯一值。 异或版：123def single_number(nums) nums.inject &#123;|result,num| result ^=num &#125;end","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://ftandy.com/categories/leetcode/"}],"tags":[],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://ftandy.com/categories/leetcode/"}]},{"title":"批判和探索自我","slug":"2015-05-17-","date":"2015-05-17T07:39:46.000Z","updated":"2015-10-04T11:08:11.000Z","comments":true,"path":"2015/05/17/2015-05-17-/","link":"","permalink":"https://ftandy.com/2015/05/17/2015-05-17-/","excerpt":"我一直觉得，在生活中看到了什么，就要跟自己探讨，要把事实摆出来，然后跟自己辩论，判断这件事究竟正确不正确。 所以我把我最近的生活摆出来，跟自己探讨一下，自己现在的生活到底正确不正确。","text":"我一直觉得，在生活中看到了什么，就要跟自己探讨，要把事实摆出来，然后跟自己辩论，判断这件事究竟正确不正确。 所以我把我最近的生活摆出来，跟自己探讨一下，自己现在的生活到底正确不正确。 客观地来说，我真是非常讨厌我现在周围的环境，这么说吧，我的寝室现在有4个人，我，两个东北人，一个湖北人。 我在寝室平时就写代码，刷知乎微博看电影美剧漫画，看各种书和资讯。 其中一个东北人就经常打拳王和lol看各种直播，还把声音开得非常大。 另外一个东北人同上。 一个湖北人因为考研，经常会去图书馆看书，回到寝室就玩斗地主，看各种美女俊男的唱歌直播，玩劲乐团。 我们几个人基本上没有什么交流，我有时候会问一下考研的人什么时候有学位课要上，然后酌情去上课。然后各自就是各种冷清。我在这里非常不开心，感觉没有人可以跟我交流，自己做的事情跟他们完全不搭，学校各种烂课，但是学位证毕业证还是很重要的，还是要把大学读完。 大一大二我还没有发现自己原来这么幼稚自我感觉还好一点，当更多地接触这个世界的时候，发现自己实在太过于幼稚了。原来别人都是这么过的生活，而我自己却在这个垃圾堆里面。自己非常气愤，为什么自己的以前的视野这么窄小，为什么我之前没有看到别人的生活，就算看到了也没有努力去改变。对自己无知的愤怒，把自己困在这么一个环境，真是非常可笑。 家庭和学校灌输给我的观念是非常幼稚的，而自生的天赋也是有限的，世界是非常大的，自身的欲望是无限的。而在生活的过程中发现的这些差距，会令自己非常地痛苦。假如人的欲望是这么地强大，那么其中的一个方法就是安慰自己，通过各种手段令自己的欲望不要过于强大，那么自己的失败感就不会过于强烈。另一种途径就是通过自己的基于家庭学校的教育，自生的天赋，努力改变自身，减少欲望和自身的差距。 自身的欲望很大一部分来源于自己看到的外界物质，假如看不到这些外界的物质，看不到别人居然可以这么活，活得这么牛逼，那么大多数人都只是安于现状的。可以说，自身的欲望，非常大是来源于外界的物质与自身拥有物质的差距。假如这个世界上每个人都能享受皇帝般的待遇，那么人相互之间差距非常小，人的欲望就会减少。或者假如这个世界上每个人都只能去耕田去获取自己生活基本的需求，那么人的欲望也是会减少的。但是现实世界中并不是这样的，每个人出生时候的差距因为家庭，基因，地域，文化等因素变得非常巨大。从而造成了每个人所面对的待遇都不一样。当这种差距出现的时候，拥有物质少的一方因为看到差距的存在就会感觉非常不安，而这种不安的感觉还是基于物种的天生属性的。因为当物种看到某种可以更适合自己发展和生活的地方的时候，就会有这种欲望去争取，希望自己可以获取那种资源。这是物种进化的使然，是根植在我们基因当中，是无法改变的。而在争取这种资源的过程中，无论怎么样，都会遇到一定的困难。假如这条路是别人走过的，像编程，是需要去参考别人是怎么走来的，这个过程对于目标是山顶，但是自己是在谷底的人是非常痛苦的。在这痛苦的过程中，人还是希望生活还是美好的，所以安慰自己谷底是非常美好的地方，沉醉于自己的安慰，即使看到了山顶也不去探索。这也是物种进化的使然，当自己拥有一定资源的时候，不愿意去冒险丢失自己拥有的资源，认为自己是幸福的。 人类的进化通常都是反馈给人类自身的。在近代人类历史上，我相信人类出生的时候，智商高低一定是占一定比例的，但是这些人在后世有没有做出伟大的事情是要根据出生的人当前的环境所决定的。一个人的一生成就我认为是由天赋＋当前家庭的环境＋当前的社会环境＋当前的气候地理环境所决定的，什么努力和毅力都是第n因素，都是可以归类到这几个基本因素组合里面的。例如，努力＝大脑发育良好＋家庭教育给予的良好教育＋社会当前的发展情况＋良好的气候环境。这几个要素就可以造成一个非常优秀的人了。而他在一生中的所有成就都可以由这几个因素来解释。 人也是可以改变这几个基本要素的，既可以通过上一代给下一代改变，也可以通过自身来改变，也可以是社会对人的改变。例如人可以通过筛选优秀的伴侣来提高自己的孩子获得优秀的基因的几率；可以获取更多的社会资源来给自己的孩子更多物质选择，给孩子培养良好的思维方式；移民到一个更加优秀的国家提供更好的社会环境；搬到一个更加舒适的地方。这是通过上一代改变下一代。 但是当自己不是那个幸运儿，没有那么良好的基本因素，自己也是可以通过自身拥有的初始条件去改变自我的。但是这些都是以这些基本要素为上限的。可以说，这些要素的自由组合形成一个人的一生。 历史上那些成就都是在一些基础条件比较奇特的人身上产生的是。因为没有前人经验，最开始那批前人只能模仿自然，根据自然的经验来总结来提高自己总结规律，获取资源。而后来的一批人，则通过模仿自然和根据前人的规律来提高自己总结规律。人类近代历史就是这么一步一步走来的，一步比前一步优秀。 但是人还是很苦逼的。人的大脑那么复杂，分泌出那么多激素，看到那么美好的世界，发现了那么多的自然规律，总结了那么多东西出来，还是要归于尘土。永恒和完美的人生是不存在的。人只能活在当下，恐惧着未来，并且做点什么。而那点什么也是不重要的，哎。","categories":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}],"tags":[],"keywords":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}]},{"title":"Vagrant 初探","slug":"2015-05-11-vagrant","date":"2015-05-11T05:38:04.000Z","updated":"2015-10-04T11:08:57.000Z","comments":true,"path":"2015/05/11/2015-05-11-vagrant/","link":"","permalink":"https://ftandy.com/2015/05/11/2015-05-11-vagrant/","excerpt":"什么是 Vagrant？简单来说，Vagrant 就是一个虚拟机的管理工具，运行在全平台上，主要用 Ruby 语言开发，只有命令行，没有 GUI。下面是 Vagrant 的在操作系统中的原理图：","text":"什么是 Vagrant？简单来说，Vagrant 就是一个虚拟机的管理工具，运行在全平台上，主要用 Ruby 语言开发，只有命令行，没有 GUI。下面是 Vagrant 的在操作系统中的原理图： 为什么要使用 Vagrant？为什么我要使用 Vagrant？假如我要虚拟一个操作系统，直接用虚拟机不就完了吗？ 从个人的角度上，你完全可以使用图形化的虚拟机完成你想要的任何操作，你也可以把操作好的虚拟环境文件传给你其他的小伙伴。 但对一个开发团队来说，传统的虚拟机软件体积庞大，图形化管理，配置蛋疼。假如由于某些需求，或者团队成员之间开发沟通成本比较大的时候，统一团队系统环境比较蛋疼。可以说，Vagrant 的主要功能就是，给那些需要统一各队员本地软件运行环境的团队使用的。其次就是模拟一些拥有部署环境的虚拟服务器，类似 AWS，国内很少用到这点。 Vagrant有以下特点： configure（可配置） reproducible（可重置） portable（非常轻便） 下面的 demo 流程基本上就能提现出上面三点。 怎么使用 Vagrant？使用 Vagrant 必须要基于某种虚拟机，virtual box 是 vagrant 官网推荐免费的非常轻巧的虚拟机。如需要其他的高大上的虚拟机，可以参考这里进行购买。下面我们使用 Vagrant，基于 OS X 安装。 Step1（下载）到这里下载 virtual box 并安装。到这里下载 Vagrant 并安装。下一个 ubuntu 镜像的.box文件。（其他镜像到这里下载）好，这么就可以开始了。 STEP2（配置和初始）在你下载的 ubuntu 镜像目录下将这个.box文件添加到 vagrant 的 box 管理列表，并随便取一个名字。 123$ vagrant box add ~/precise64.box --name lol$ vagrant box listlol (virtualbox, 0) 在你平时搞 project 的地方创建一个管理 vagrant demo 的文档，创建一个 demo1，然后用 init 创建刚刚加的 lol box。 12$ cd ~/Project &amp;&amp; mkdir vagrant &amp;&amp; cd vagrant &amp;&amp; mkdir demo1 &amp;&amp; cd demo1$ vagrant init lol 这时候你会看到 vagrant 会生成一个配置文件 Vagrantfile，可以打开进去读读里面的配置信息。然后启动吧。 1$ vagrant up 这时候会初始化一些东西，然后后台就会开启一个相对于当前文档的 ubuntu 虚拟机，可以进去查看一下。 123456789$ vagrant global-statusid name provider state directory220609b default virtualbox running /Users/FTAndy/Project/vagrant/demo5$ vagrant ssh...vagrant@precise64:~$ STEP3(做些什么)进入了虚拟机之后就可以配置你想要的环境了，可以安装一个 nginx 玩玩。 12vagrant@precise64:~$ sudo apt-get updatevagrant@precise64:~$ sudo apt-get install nginx 在外面的 Vagrantfile 上设置 forwarded_port，将 guest 的80映射到 host 的8080。退出虚拟机之后 reload 一下配置。 12345config.vm.network :forwarded_port, guest: 80, host: 8080vagrant@precise64:~$ exit$ vagrant reload OK。访问一下本地的8080端口吧。“Welcome to nginx!” 最后，可以把你做的东西打包起来，拿到.box文件，传给别人用。 1$ vagrant package 然后会生成一个 package.box 文件，给你的小伙伴用吧。 其它1.销毁 可以通过三种方式挂起活着关闭后台的vagrant程序： vagrant suspend(挂起，把虚拟机内存存到硬盘里，恢复快) vagrant halt(关闭，内存完全释放，纪录操作信息，恢复慢) vagrant destroy(销毁，把内存销毁，不会有任何记录，无法恢复) 2.同步文件 默认会同步所有在 Vagrantfile 下的文档和文件到根目录的 /vagrant下，在外面编辑同时会同步到虚拟机里面。 3.外网映射机制 Vagrant 的网络配置支持3种： Forwarded ports 将虚拟机的某个端口绑定到本机端口。 Private networks 分配给虚拟机一个私有 ip，这样可以在本机上访问虚拟机的所有端口。 Public networks 让虚拟机暴露在真实的网络中，跟本机同等。 用来开发的话，Forwarded ports 和 Private networks 就够了，如果要开放的端口比较多并且要用 rsync 这样的工具的话，Private networks 更方便。如果要给内网部署 Gitlab 这样的工具给团队使用，则使用 Public networks。 4.常用命令 123456789101112131415161718192021$ vagrant box add ~/xxx.box --name \"your_box_name\"$ vagrant box list$ vagrant init \"your local box or online box\"$ vagrant up —provider=virtural_box$ vagrant global-status$ vagrant status$ vagrant reload$ vagrant package$ vagrant halt$ vagrant suspend$ vagrant destroy 参考资料 http://segmentfault.com/a/1190000000264347 http://chloerei.com/2013/11/01/vagrant/ https://www.vagrantup.com/ https://github.com/mitchellh/vagrant https://www.vagrantup.com/","categories":[{"name":"vagrant_docker","slug":"vagrant-docker","permalink":"https://ftandy.com/categories/vagrant-docker/"}],"tags":[],"keywords":[{"name":"vagrant_docker","slug":"vagrant-docker","permalink":"https://ftandy.com/categories/vagrant-docker/"}]},{"title":"Ruby 对象和类模型","slug":"2015-04-21-ruby","date":"2015-04-21T05:43:32.000Z","updated":"2015-10-04T11:09:53.000Z","comments":true,"path":"2015/04/21/2015-04-21-ruby/","link":"","permalink":"https://ftandy.com/2015/04/21/2015-04-21-ruby/","excerpt":"用 Ruby 也快有一年了，总结一下 Ruby 中对象和类模型，表达不是很熟练，请轻喷。","text":"用 Ruby 也快有一年了，总结一下 Ruby 中对象和类模型，表达不是很熟练，请轻喷。 Ruby的对象和类模型到底是什么鬼？在 Ruby 的世界中，有这么三个原则： 所有东西都是对象，除了 method 和 block 所有对象都有一个类 类最终都继承自源类 Object，而 Object 继承自 BasicObject 在这个描述中，假设定义了一个类 Dog，实例化一个对象 tidy，对象 tidy 的类是 Dog，Dog 类的类是 Class，Class 继承自 Module，Module 继承自 Object，Object 最终继承自源类 BasicObject，BasicObject 也是对象，那 BasicObject 的继承自谁？ 在这里我打开 irb，ruby 的版本为2.1.2，进行操作。 12345678class Dog ; endtidy = Dog.newtidy.class #=&gt; DogDog.class #=&gt; ClassClass.superclass #=&gt; ModuleModule.superclass #=&gt; ObjectObject.superclass #=&gt; BasicObjectBasicObject.superclass #=&gt; nil 很明显，BasicObject 没有超类，这条贪食蛇吃到这里就终止了。而Dog继承关系上的类概念：Dog，Class，Module，Object，BasicObject 的类都是 Class。 也就是说我可以创建这些类概念的实例对象，Dog 就是一只狗，Class 就是一个类，Module 就是一个模块，Object 就是一个对象，BasicObject 就是一个基础对象。而 Dog，Module 和 Class 自己本身都是 Class 类的一个实例对象，可以去创建我们想要用的概念对象。 而 Object 和 BasicObject 包括一些对象的基本方法，例如 Object 的 nil? 方法，因为所有对象都会继承自 Object，所以所有对象都会有 nil 方法；又例如 BasicObject 的 instance_eval 方法，因为所有对象 也会继承自 BasicObject，所以所有对象也会有instance_eval 方法。这些方法都可以在 Ruby的手册上看到。 这里我画了一个继承的图出来。 那 BasicObject 和 Object 有没有 nil? 和instance_ev 方法呢？当然会有，因为他是 Class 的实例对象，对象都继承 Object 和 BasicObject，他们都可以享有自己的方法。 而我们在讨论对象和类模型的时候一般都会忽略掉 BasicObject，因为他置于最顶层，我们不会轻易改变他们，而只讨论 Object 以下的对象和类。 eigenclasseigenclass 也叫元类或者单件类。eigen 的意思为本质的，换我们中国人古代的概念应该叫元神。每个对象都有自己的 eigenclass，可以通过连个方法找到他。下面代码找出了一只泰迪狗和 Dog 类的元类。 12345678910111213141516def Dog ; endtidy = Dog.newtidy_eigenclass = class &lt;&lt; tidy selfend tidy_eigenclass =&gt; #&lt;Class:#&lt;Dog:0x000000023bc5e8&gt;&gt;tidy_eigenclass.class #=&gt; Classtidy_eigenclass.superclass #=&gt; DogDog_eigenclass = class &lt;&lt; Dog selfendDog_eigenclass=&gt; #&lt;Class:Dog&gt;a = Dog_eigenclass.class=&gt; ClassDog_eigenclass.superclass=&gt; #&lt;Class:Object&gt;Dog_eigenclass == a #=&gt; true 上面的代码的意思是：在泰迪狗和 Dog 类的之前还有一个 eigenclass，Dog 类与 Class 类之前还有一个 eigenclass。其实可以通过 class &lt;&lt; XXX 和 XXX.singleton_class 两种方法来找到对象的元类： 12345Dog_eigenclass = class &lt;&lt; Dog selfendDog_eigenclass=&gt; #&lt;Class:Dog&gt;Dog.singleton_class=&gt; #&lt;Class:Dog&gt; 那元类有什么作用呢？其实有了元类，当我们想要扩展对象和类自身的方法而非继承方法的时候，就变得非常容易，而且可以使用很多种方法来实现。 12345class Dog def self.bar \"wowowo\" endend 1234567class Dog class &lt;&lt; self def bar \"wowowo\" end endend 123def Dog.bar \"wowowo\"end 12345class &lt;&lt; Dog def bar \"wowowo\" endend 上面的定义代码使得 Dog 类都可以用 Dog.bar 来输出”wowowo”。对类来说，可以使用 class_eval 来打开自己来操作类自己。对对象和类来说，可以使用 instance_eval来打开自己的 eigenclass 来操作自己。其实自己再画一个继承图就很好理解了。 其实还有一个 nil 我还没有画，而 nil 的 class 是 NilClass。当定义一个 Dog，和实例一个对象 tidy 就成这样的图了。这个只是局部的显示出 eigenclass 视图。有人做出了一个不包含 eigenclass 的 Ruby 常用类的关系图，真心跪了。 总结想要精通 Ruby，完全熟悉 Ruby 的对象和类模型是不可缺失的一步。 参考 Understanding the Ruby object model Why classes are confusing in Ruby Something confusing about Ruby: Object and Class Ruby’s Eigenclasses Demystified Ruby元编程 stackoverflow","categories":[{"name":"ruby","slug":"ruby","permalink":"https://ftandy.com/categories/ruby/"}],"tags":[],"keywords":[{"name":"ruby","slug":"ruby","permalink":"https://ftandy.com/categories/ruby/"}]},{"title":"Ruby 元法术","slug":"2015-04-05-ruby","date":"2015-04-05T05:38:04.000Z","updated":"2015-10-04T11:09:59.000Z","comments":true,"path":"2015/04/05/2015-04-05-ruby/","link":"","permalink":"https://ftandy.com/2015/04/05/2015-04-05-ruby/","excerpt":"《Ruby元编程》 之后《Ruby元编程》这本书用两个字总结：法术。用一个句话总结：根本没有什么元编程，只有编程而已。","text":"《Ruby元编程》 之后《Ruby元编程》这本书用两个字总结：法术。用一个句话总结：根本没有什么元编程，只有编程而已。 对于 Ruby 来说我接触到 Ruby 这个语言源于 Rails，但我不希望自己学习 Ruby 只是终于 Rails，终于 Web。所以我想要熟悉 Ruby，精通 Ruby，想要知道他是什么，他能干些什么，为什么 Rails 能用 Ruby 写出来。 Ruby的元我对元的理解是，事物对自己的抽象。一个编程语言想要应用到现实世界中，非常需要中间层来一层层地将想要描述的事物抽象出来。Ruby 的语言设计和元能力有两个优点。 非常符合这种现实世界对于编程语言的需求。 Ruby 语言的写法精简，抽象程度高，语法对程序员友好。 但是 Ruby 语言的性能问题和对应用高并发情况出现的处理能力一直被人诟病。不过好像2.0++的版本出来后，性能得到了质的飞跃，再也没有什么人说 Ruby 性能的坏话了。 法术《Ruby元编程》附录中的法术手册就是 Ruby 元编程的一个总结。我认为，假如你把附录中的法术都掌握之后都不用看这本书了。这本书就是详解剖析这些东西而已。下面的例子在 Ruby 2.1.2版本下测试。假若你已经对这些字眼非常了解，就不必往下看了。当然我没有非常详细的解析，只是一个括览： Around Alias 环绕别名 Blank Slate 白板 Class Extyension 类扩展 Class Extension 类扩展混入 Context Probe 上下文探针 Dynamic Method 动态方法 Deferred Evaluation 延迟执行 Dynamic Proxy 动态代理 Flat Scpoe 扁平作用域 Kernel Method 内核方法 Monkeypatch 猴子补丁 Object Extension 对象扩展 Shared Scope 共享作用域 Around Alias 环绕别名12345678class String alias old_reverse reverse def reverse \"x#&#123;old_reverse&#125;x\" endend\"abc\".reverse # =&gt; \"xcbax\"\"abc\".old_reverse # =&gt; \"cba\" old_reverse 和 reverse互 用，但是重新定义 reverse，old_reverse 指向原来的 reverse。 Blank Slate 白板12345678910111213class C def method_missing(name, *args) \"a Ghost Method\" endendobj = C.newobj.to_s # =&gt; \"#&lt;C:XXXX&gt;\"class C instance_methods.each do |m| undef_method(m) unless m.to_s =~ /method_missing|resopnd_to?/ endendobj.to_s # =&gt; \"a Ghost Method\" 书里面有个 BUG，用来匹配的正则是“/method_missing|resopnd_to?|^/”，这样把所有方法都匹配到了。而且 Ruby 这里比较有意思的是“=~”匹配的时候，真返回0，假返回 nil。Ruby 里面的判断有值就为真，而 C 和 C++ 都会将0设为 false，1设为 true。定义了一个类的 method_missing 方法时候，对象调用了一个不知名方法，就会直接调用 method_missing。method_missing 也是很多 Ruby 魔法的根源。 Class Extyension 类扩展123456789101112class C ; endmodule M def my_method \"a class method\" endendclass &lt;&lt; C include MendC.my_method # =&gt; \"a class method\"a = C.newa.my_method # =&gt; \"NoMethodError: undefined method `my_method' for #&lt;C:0x000000029d5c68&gt;\" 这里对类进行方法扩展，但是对于创建类的对象是没有这个方法的。 Class Extension 类扩展混入12345678910111213141516module M def self.included(base) base.extend(ClassMethods) end module ClassMethods def my_method \"a class method\" end endendclass C include MendC.my_method # =&gt; \"a class method\" 这里的 self.included(base) 使用了类的钩子功能，Ruby 还有其他的钩子方法。当类C include M的时候，触发了模块M的钩子方法 included，所以 base 就是C，然后C再扩展了M模块的 ClassMethods 的所有方法。 Context Probe 上下文探针1234567class C def initialize @x = \"some thing\" endendobj = C.newobj.instance_eval&#123;@x&#125; instance_eval 可以打开对象自己，操作自己内部。 Dynamic Method 动态方法12345678class C ; endC.class_eval do define_method :my_method do \"a dynamic method\" endendobj = C.newobj.my_method # =&gt; \"a dynamic method\" class_eval 可以打开一个类，对类进行操作。 Deferred Evaluation 延迟执行12345678910111213class C def store(&amp;block) @my_code_capsule = block end def execute @my_code_capsule.call endendobj = C.newobj.store&#123;$X = 1&#125;$X = 0obj.execute$X # =&gt; 1 可以动态地将一个块存到对象的一个变量中。 Dynamic Proxy 动态代理1234567891011class MyDynamicProxy def initialize(target) @target = target end def method_missing(name, *args, &amp;block) \"result: #&#123;@target.send(name, *args, &amp;block)&#125;\" endendobj = MyDynamicProxy.new(\"a String\")obj.reverse # =&gt; \"result: gnirtS a\" 使用到了 method_missing 和 send。Duang。另外一个魔法诞生了。 Flat Scpoe 扁平作用域123456789101112class C def an_attribute @attr endendobj = C.newa_variable = 100obj.instance_eval do @attr = a_variableendobj.an_attribute # =&gt;100 就是使用了 instance_eval 和闭包嘛。 Kernel Method 内核方法123456module Kernel def a_method \"a kernel method\" endenda_method # =&gt; \"a kernel method\" 在 kernel 模块中定义方法，所有对象可见。 Monkeypatch 猴子补丁123456class String def reverse \"override\" endend\"abc\".reverse # =&gt; \"override\" 著名的猴子补丁，在 runtime 中改变类和对象的属性和方法。guerrilla patch 拟音 gorilla patch ，然后变成了 monkey patch。 Object Extension 对象扩展12345678910obj = Object.newmodule M def my_method \"a singleton method\" endendclass &lt;&lt; obj include Mendobj.my_thod # =&gt; \"a singleton method\" 对 obj 的元类进行扩展，混入模块 M 的方法。 Shared Scope 共享作用域12345678910111213141516lambda &#123; shared = 10 self.class # =&gt; Object self.class.class_eval do define_method :counter do shared end define_method :down do shared -= 1 end end&#125;.callcounter # =&gt; 103.times &#123;down&#125;counter # =&gt; 7 lambda 对 Object 对象进行操作，并且共享变量。 总结其实这些东西熟悉了这些东西之后，还是那句话：根本没有什么元编程，只有编程而已。","categories":[{"name":"ruby","slug":"ruby","permalink":"https://ftandy.com/categories/ruby/"}],"tags":[],"keywords":[{"name":"ruby","slug":"ruby","permalink":"https://ftandy.com/categories/ruby/"}]},{"title":"第一篇","slug":"2015-03-20-life","date":"2015-03-20T18:53:33.000Z","updated":"2016-02-22T08:10:09.000Z","comments":true,"path":"2015/03/21/2015-03-20-life/","link":"","permalink":"https://ftandy.com/2015/03/21/2015-03-20-life/","excerpt":"开篇大三下了。正式开始记录自己的一些东西。但不知道该写些什么。那就瞎扯一些东西吧。","text":"开篇大三下了。正式开始记录自己的一些东西。但不知道该写些什么。那就瞎扯一些东西吧。 Be reborn again重生。这两个字令我突然回想起凯文史派西这个演员，从我开始认识他的《纸牌屋》这部剧。脑海中付出他那经典的略带奸邪的微笑。回想起《美国丽人》中他第一次见到珍妮的那位美丽无比的朋友时候那种微笑，然后回到家想象着那美丽的生物在他老婆身边jerk off。那种玫瑰掉下来，憧憬着美好的未来，违背着自己生活，重获新生，然后jerk off的感觉。 这部神剧就是讲一个中年男人如何发现自己，拯救自己和周围，但最后拯救失败（被杀）的故事。一个中年人到了那个年纪才发现自己生活在一个自己厌恶甚至憎恨的环境下，真是可悲。当他开始发现真正的自我的时候，体现出强烈的生命力和欲望，想要重新生活，然而身边的各种人和物早不允许他这么拯救自己，最到导致被杀的悲剧。 这部剧给我一个最终的感慨是，当自己身边的环境已经非常固化的时候，想要改变自己真的已经非常困难了，更加不要去说有什么理想去改变世界，唉，真是可笑。 我对这部电影非常有感觉的原因是，我发现自己也处于这个可笑的阶段。家庭观念的固化，家庭的堕落，社会的种种不公，zf的各种不作为，社会人的各种浮躁。令我感觉自己就是里面的主人公，所以自己非常想要提高自己的能力去去改变自我。我实在不想要去过自己人生前20年那种生活，没有任何目标，浮躁，懒惰，软弱。所以我想要在我人生的轨迹上画出一道折线，而不是一直平淡无奇的直线下去。 元思考能力元能力是什么？元是什么意思？有一天你遇到了愿望神，可以许三个愿望，第三个愿望你希望再得到三个愿望。愿望神必须请示元愿望神去让你得到这三个愿望。假如你不满足，让第三个愿望再获得三个愿望，元愿望神就必须向元元愿望神请示，如此下去。。。 而思考的元能力是指自己思考中的更高层的思考，就像是一个更高层的我在指挥最底层的我思考一样。知乎上有少这类的答案：采铜；百度百科也有：元认知。说白了就是抽象的能力。 《从0到1》看完《从0到1》这本关于创业公司的书之后，我就记录了一个地方的信息。 在书本的第129页到130页将了关于一个“大学炸弹客”的故事 。“你可能认为那篇声明的写作风格明显带有精神错乱的迹象，可是它却出奇地令人信息。卡辛斯基指出：为了幸福，每个人都‘需要制定目标，并付诸努力，并且知道要实现几个这样的目标’。他将人们的目标分为三组： 1.稍作努力即可达到的目标。 2.不懈努力才能达到的目标。 3.再怎么努力都不可能达到的目标。” Peter Thiel / Blake Masters Zero to one 最后留给自己瞎扯也没有瞎扯到自己，说说自己吧。 大三下了，家庭财务情况愈变惨烈，所以我也没有准备考研，也没有钱出国，毕业之后还是直接面向工作。现在有一份远程的开发工作，先应付着自己的生活开支。 我看过BAT三家的后台开发，研发实习生面试题，基本都是偏向 C++ 和 JAVA，要有非常好的操作系统，计算机网络，算法，程序设计的能力，有好多题都不会。我个 rubyist 就暂时不去捣这个乱了，把这些知识都认真补好，一年后再去迎战。 所以这一年的任务就是做好手头的 ruby 工作，拼命读多点关于操作系统，计算机网络，算法，程序设计的书，最重要是算法的书，这个环节真是太薄弱了。 之前看过一个知乎答案，一个 facebook 员工说，想要进 facebook，你首先是一个受过良好教育的完整人，然后是一个计算机基础特别好的计算机学生，最后才是牛逼的软件工程师。这是一个循序渐进的过程，而不是一步登天。 所以最终目标还是一个合格的软件开发工程师。:-) 上面提到的三组目标，我也给自己分好了毕业之后工作的目标： 稍微努力：普通的软件公司或正在上升的创业公司。 不懈努力：BAT 等传统的国内的龙头公司。 不可达到：国外的G家，T家，F家，M家等大公司。","categories":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}],"tags":[],"keywords":[{"name":"life","slug":"life","permalink":"https://ftandy.com/categories/life/"}]}]}